<!-- Generated by SpecStory -->

# Renaming and redesigning genesis_tasks (2025-07-02 18:33Z)

_**User**_

genesis_tasks 能不能改名并且设计得更加通用因为后面不止创世任务是异步的

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Proposing table renaming**

The user is asking if we can rename the `genesis_tasks` table and make it more generic, since it’s currently focused on asynchronously managing Genesis tasks. They’re considering renaming it to something like `async_tasks` or simply `tasks`. I think I should suggest an approach where we first clarify the scope of this change, identify the parts of the code that need modification, and ensure that the changes are minimal while fitting the user’s needs.</details></think>

---

可以，而且非常推荐及早把异步任务表抽象成“通用异步任务”概念。下面给出一套渐进式改造方案，既兼容现有 Genesis 逻辑，又为今后其它模块（投稿、审核、导出、推送等）复用做准备。

─────────────────────────────
一、总体思路
1. 将表从 `genesis_tasks` 改名为 `async_tasks`（或 `system_tasks`、`background_tasks`，任选一个能清晰表达“后台异步任务”的名字）。
2. 把所有 Genesis-专属字段抽离为可选、可扩展的“上下文”字段：
   • 用 `context_type` + `context_id` 代替 `session_id / target_stage`  
     （例如：`context_type = 'genesis_session', context_id = <uuid>`；或 `context_type = 'export_job', context_id = <uuid>`）。
3. 将 `genesis_task_type` 枚举改为更泛化的 `task_kind`（或 `task_category`），并把值命名为业务无关的动词短语，如 `data_generation`、`data_refinement`、`file_export`、`notification_send` 等。
4. 保留 `task_status` 枚举不变（已足够通用）。
5. 触发器 & 辅助函数改名、松耦合：
   • `create_genesis_task` → `create_async_task`
   • `complete_genesis_task` → `complete_async_task`
   • …并去掉与 Genesis 专属表的 FK 依赖。
6. 视图、索引、清理与统计函数同步改名并使用新字段。

─────────────────────────────
二、迁移步骤（PostgreSQL 语法）

1. 改表名  
```sql
ALTER TABLE genesis_tasks RENAME TO async_tasks;
```

2. 新增上下文字段并迁移数据  
```sql
ALTER TABLE async_tasks
    ADD COLUMN context_type VARCHAR(50) NOT NULL DEFAULT 'genesis_session',
    ADD COLUMN context_id   UUID NOT NULL;

-- 把旧 session_id 写入 context_id
UPDATE async_tasks
SET context_id = session_id;

-- （可选）如果后续不再直接使用 session_id，可改为 NULLABLE 或删除
```

3. 删除 Genesis 特有外键 & 字段（如果确定不再需要）  
```sql
ALTER TABLE async_tasks
    DROP CONSTRAINT async_tasks_session_id_fkey,
    DROP COLUMN session_id,
    DROP COLUMN target_stage;
```

4. 改枚举 & 字段  
```sql
-- 1) 创建新枚举
CREATE TYPE task_kind AS ENUM (
  'data_generation',
  'data_refinement',
  'worldview_generation',
  -- …把现有值映射进来或新增更多
);

-- 2) 把旧列替换
ALTER TABLE async_tasks
  RENAME COLUMN task_type TO task_kind,
  ALTER COLUMN task_kind TYPE task_kind USING task_type::text::task_kind;
  
-- 3) 删除旧枚举
DROP TYPE genesis_task_type;
```

5. 重命名函数 / 触发器（示例）  
```sql
ALTER FUNCTION create_genesis_task(...)  RENAME TO create_async_task;
-- 函数内容把旧字段/表名替换成新字段/表名
```

6. 同步更新视图与统计函数  
```sql
CREATE OR REPLACE VIEW async_task_summary AS
SELECT
  at.id,
  at.context_type,
  at.context_id,
  at.task_kind,
  at.status,
  at.progress,
  ...
FROM async_tasks at;
```

7. 代码层面影响
• ORM / Repository 层：更新表名、列名、枚举名。  
• 业务逻辑：调用新建、更新、查询任务的服务时，增加 `context_type` / `context_id` 入参。  
• GraphQL / REST API：参数 & 返回字段同步调整。  
• 旧 Genesis 功能：在创建任务时固定传 `context_type='genesis_session'` 即可无缝继续使用。

─────────────────────────────
三、向后兼容策略

如果担心一次性修改过多，可分两步：
1. 先“加字段 + 改函数”但保留旧字段（`session_id` 等）和旧函数别名，确保现有代码不改也能跑。  
2. 逐步把业务代码迁移到新接口后，再删除旧字段 / 别名。

─────────────────────────────
四、改造收益

• 单一异步任务表，避免未来各模块各建一张表导致查询/监控分散。  
• 通过 `context_type` + `context_id` 实现跨业务聚合统计（例如全站异步任务成功率、执行时长排名）。  
• 后续再新增任务种类时，仅补充 `task_kind` 枚举值即可，无需改表结构。  
• 统一触发器与辅助函数，减少重复代码。

─────────────────────────────
五、小结

是的，完全可以把 `genesis_tasks` 抽象为通用异步任务表。  
推荐遵循上述方案：  
1. 改名 `async_tasks`（或其它中性名称）；  
2. 引入 `context_type/context_id`；  
3. 泛化 `task_kind`；  
4. 同步函数/视图。  

如此既保留现在的业务能力，也为未来扩展打下坚实基础。

---

_**User**_

result_step_id 呢？

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Creating a generalization plan**

I'm focusing on crafting a message that outlines the rationale, suggestions, and migration steps to generalize a concept. It seems straightforward; I won't need tool calls or technical details, just a clear and conceptual answer. I think about the best way to structure my response so it effectively communicates the plan. I want to make it easy for the user to follow and understand, ensuring that every part connects well.</details></think>

---

`result_step_id` 这列目前强耦合到 `genesis_steps`。  
如果要把整张表抽象成“通用异步任务”，那条 **“结果指向”** 也应该像任务的 “上下文” 一样，多态化。推荐 3 种做法，按灵活度与实现成本排序：

─────────────────────────────
1. **双字段多态引用（最通用，推荐）**  
```
result_entity_type   VARCHAR(50)   -- 结果实体类型，如 'genesis_step'、'export_file'、'audit_record'
result_entity_id     UUID          -- 对应实体表主键
```
• 与 `context_type/context_id` 形成对称设计。  
• 值得引用任何结果对象，无论是步骤、文件、记录还是其它。  
• 如果某些任务没有结构化结果，仅用 `result_data` JSON 即可，把两列留空。

迁移示例：
```sql
ALTER TABLE async_tasks
  ADD COLUMN result_entity_type VARCHAR(50),
  ADD COLUMN result_entity_id   UUID;

-- 把旧数据迁过去
UPDATE async_tasks
SET
  result_entity_type = 'genesis_step',
  result_entity_id   = result_step_id;

-- 迁移完再删掉旧列 & 外键
ALTER TABLE async_tasks
  DROP COLUMN result_step_id;
```

─────────────────────────────
2. **保持 `result_data` JSONB，去掉外键**  
• 如果大多数任务结果都可以 JSON 化（例如文本、统计、URL），直接继续用 `result_data` 存储。  
• 当需要结构化索引时，再按具体业务在其它表落地。  
• 代价最小，但失去外键完整性与快捷 JOIN。

─────────────────────────────
3. **拆分“领域结果表”**  
• 异步任务表只管状态；真正的结果由各业务自己存到专属表。  
• 用 `context_type/context_id` 反向查询或在 `result_data` 里存指向信息。  
• 适合结果特别大或有复杂专属字段的场景（比如导出生成的多文件、统计报表等）。  
• 但跨域聚合查询时要多一次 JOIN。

─────────────────────────────
【推荐策略】  
• 采用 **方案 1**：`result_entity_type + result_entity_id`，保持外键能力并且完全通用。  
• 如果短期内只有 Genesis 会写入结果，可保留一个 **视图** 来兼容旧代码：
```sql
CREATE OR REPLACE VIEW genesis_task_result AS
SELECT id,
       result_entity_id AS result_step_id
FROM   async_tasks
WHERE  result_entity_type = 'genesis_step';
```
现有查询无需立刻改动。

这样，`async_tasks` 既能继续关联 `genesis_steps`，又为以后任何新任务类型预留了统一的结果指针。

---

