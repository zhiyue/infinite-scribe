<!-- Generated by SpecStory -->

# Fixing invalid conditional operand error (2025-07-10 11:17Z)

_**User**_

For the code present, we get this error:
```
Invalid conditional operand of type "Column[datetime]"
  Method __bool__ for type "Column[datetime]" returns type "Never" rather than "bool"
```
How can I resolve this? If you propose a fix, please make it concise.

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user is getting a linter error about invalid conditional operands in their User model's `to_dict` method. Looking at the error and the code, the issue is on lines 104-105 where they're checking:

```python
"created_at": self.created_at.isoformat() if self.created_at else None,
"updated_at": self.updated_at.isoformat() if self.updated_at else None,
```

The error message says that `self.created_at` and `self.updated_at` are of type `Column[datetime]` and their `__bool__` method returns `Never` rather than `bool`. This suggests that these fields are SQLAlchemy column definitions rather than actual datetime values.

Looking at the User model, I can see that `created_at` and `updated_at` are defined as:

```python
# From the BaseModel, these are likely defined as:
# created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)
# updated_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)
```

But wait, let me look more carefully. In the comment it says "# 假设你有一个 BaseModel" (assumes you have a BaseModel). So the `created_at` and `updated_at` fields are likely inherited from BaseModel, but they might be defined as nullable in the BaseModel.

Actually, looking at the database schema in the architecture document, I can see:

```sql
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
```

So these should be NOT NULL fields. But the Python model might have them defined as potentially nullable (`datetime | None`) which is causing the type checker to complain.

The issue is that the type checker is seeing these as potentially None, but the conditional check `if self.created_at` is not behaving as expected for SQLAlchemy columns.


I'll explicitly check against `None` to resolve the type checker error. By using `is not None`, I can ensure a more precise type check that works correctly with SQLAlchemy column definitions. This approach provides a clear, unambiguous way to handle potential null values while maintaining type safety.</details></think>

---

The error occurs because SQLAlchemy's `Column[datetime]` type doesn't support truthiness checking in the way you're using it. The type checker is complaining about the conditional `if self.created_at`.

**Fix:** Use explicit `None` comparison instead of truthiness:

---

<details><summary>Edit file: apps/backend/src/models/user.py</summary>

undefined

**Chunk 1**
Lines added: 2, lines removed: 2

```diff
@@ -102,6 +102,6 @@
              "is_verified": self.is_verified,
              "is_superuser": self.is_superuser,
-             "created_at": self.created_at.isoformat() if self.created_at else None,
-             "updated_at": self.updated_at.isoformat() if self.updated_at else None,
+             "created_at": self.created_at.isoformat() if self.created_at is not None else None,
+             "updated_at": self.updated_at.isoformat() if self.updated_at is not None else None,
              "email_verified_at": self.email_verified_at.isoformat() if self.email_verified_at else None,
          }
```

</details>

---

<think><details><summary>Thought Process</summary>Perfect! I've fixed the issue by changing the conditional checks from truthiness (`if self.created_at`) to explicit None comparison (`if self.created_at is not None`). This is more explicit and resolves the type checker error.

The fix only changes the two lines that were causing the error. The `email_verified_at` line doesn't have the same issue because it's likely defined as `datetime | None` in the model, so the truthiness check works fine for that field.

This should resolve the linter error while maintaining the same functionality.</details></think>

---

The fix changes the conditional checks from truthiness (`if self.created_at`) to explicit `None` comparison (`if self.created_at is not None`). This resolves the SQLAlchemy type checker issue while maintaining the same functionality.

---

