# 任务 5 实施计划 - 适配器层

**生成时间**：2025-01-09T22:00:00+08:00  
**任务描述**：实现ApiAdapter和AgentsAdapter，支持单进程和多进程运行模式  
**关联需求**：FR-001, FR-002, FR-004, NFR-002  
**预计工时**：6小时

## 执行概要

### 目标
实现统一启动器的适配器层，为API Gateway和AI Agents提供统一的启动/停止/状态管理接口，支持单进程和多进程两种运行模式。

### 范围
- **包含**：
  - ApiAdapter：支持单进程（uvicorn server）和多进程（subprocess）模式
  - AgentsAdapter：包装现有AgentLauncher，提供统一接口
  - 统一的适配器基类和接口规范
  - 进程管理：启动/停止/信号处理/超时控制
  - 状态监控：运行状态、健康检查、错误处理

- **不包含**：
  - 服务发现和注册中心
  - 服务间通信协议设计
  - 外部依赖服务的管理（数据库、消息队列等）

### 前置条件
- 任务1-4已完成（目录结构、配置模型、CLI基础、配置示例）
- 现有AgentLauncher (`apps/backend/src/agents/launcher.py`) 可用
- uvicorn服务器正常运行

## 技术准备

### 需要的API/库
| 库/模块 | 方法/类 | 用途 | 文档链接 |
|---------|--------|------|---------|
| asyncio | create_subprocess_exec, create_task | 多进程管理 | [asyncio docs](https://docs.python.org/3/library/asyncio.html) |
| uvicorn | Server, Config | 单进程API服务器 | [uvicorn docs](https://www.uvicorn.org/) |
| signal | SIGTERM, SIGINT, SIGKILL | 进程信号管理 | [signal docs](https://docs.python.org/3/library/signal.html) |
| os | getpgid, killpg | 进程组管理 | [os docs](https://docs.python.org/3/library/os.html) |
| httpx | AsyncClient | 健康检查HTTP请求 | [httpx docs](https://www.python-httpx.org/) |
| structlog | get_logger | 结构化日志 | [structlog docs](https://www.structlog.org/) |

### 代码位置
- **需要创建的文件**：
  - `apps/backend/src/launcher/adapters/__init__.py` - 适配器包初始化
  - `apps/backend/src/launcher/adapters/base.py` - 适配器基类
  - `apps/backend/src/launcher/adapters/api.py` - API适配器实现
  - `apps/backend/src/launcher/adapters/agents.py` - Agents适配器实现

- **需要修改的文件**：
  - `apps/backend/src/launcher/types.py` - 添加适配器相关枚举和类型

## TDD实施步骤

### 步骤1：适配器基类设计
**测试先行（RED）**：
```python
# 测试文件：tests/unit/launcher/adapters/test_base.py
import pytest
from launcher.adapters.base import BaseAdapter
from launcher.types import ComponentStatus

@pytest.mark.asyncio
async def test_base_adapter_interface():
    """测试适配器基础接口"""
    
    class TestAdapter(BaseAdapter):
        async def start(self) -> bool:
            return True
        
        async def stop(self, timeout: int = 30) -> bool:
            return True
        
        async def health_check(self) -> dict:
            return {"status": "healthy"}
    
    adapter = TestAdapter("test", {})
    
    # 验证初始状态
    assert adapter.name == "test"
    assert adapter.status == ComponentStatus.INIT
    
    # 验证抽象方法存在
    assert hasattr(adapter, 'start')
    assert hasattr(adapter, 'stop')
    assert hasattr(adapter, 'health_check')
```

**最小实现（GREEN）**：
```python
# 实现文件：apps/backend/src/launcher/adapters/base.py
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from ..types import ComponentStatus
import structlog

logger = structlog.get_logger(__name__)

class BaseAdapter(ABC):
    """适配器基类"""
    
    def __init__(self, name: str, config: Dict[str, Any]):
        self.name = name
        self.config = config
        self.status = ComponentStatus.INIT
        self._process: Optional[Any] = None
    
    @abstractmethod
    async def start(self) -> bool:
        """启动服务"""
        pass
    
    @abstractmethod
    async def stop(self, timeout: int = 30) -> bool:
        """停止服务"""
        pass
    
    @abstractmethod
    async def health_check(self) -> Dict[str, Any]:
        """健康检查"""
        pass
    
    def get_status(self) -> ComponentStatus:
        """获取当前状态"""
        return self.status
```

**重构优化（REFACTOR）**：
- 添加状态转换验证逻辑
- 增加配置验证方法
- 完善错误处理机制

### 步骤2：ApiAdapter单进程模式
**测试先行（RED）**：
```python
# 测试文件：tests/unit/launcher/adapters/test_api.py
import pytest
import asyncio
from unittest.mock import Mock, patch, AsyncMock
from launcher.adapters.api import ApiAdapter
from launcher.types import ComponentStatus

@pytest.mark.asyncio
async def test_api_adapter_single_mode_start():
    """测试API适配器单进程模式启动"""
    
    config = {
        "mode": "single",
        "host": "127.0.0.1",
        "port": 8000,
        "app": "src.api.main:app"
    }
    
    adapter = ApiAdapter(config)
    
    with patch('uvicorn.Server') as mock_server:
        mock_instance = Mock()
        mock_instance.startup = AsyncMock()
        mock_instance.serve = AsyncMock()
        mock_server.return_value = mock_instance
        
        # 启动服务
        result = await adapter.start()
        
        assert result is True
        assert adapter.status == ComponentStatus.RUNNING
        mock_server.assert_called_once()
        mock_instance.startup.assert_called_once()
```

**最小实现（GREEN）**：
```python
# 实现文件：apps/backend/src/launcher/adapters/api.py
import asyncio
import uvicorn
from typing import Dict, Any, Optional
from .base import BaseAdapter
from ..types import ComponentStatus
import structlog

logger = structlog.get_logger(__name__)

class ApiAdapter(BaseAdapter):
    """API服务适配器"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__("api", config)
        self.mode = config.get("mode", "single")
        self.host = config.get("host", "127.0.0.1")
        self.port = config.get("port", 8000)
        self.app = config.get("app", "src.api.main:app")
        self._server: Optional[uvicorn.Server] = None
        self._process: Optional[asyncio.subprocess.Process] = None
    
    async def start(self) -> bool:
        """启动API服务"""
        try:
            self.status = ComponentStatus.STARTING
            
            if self.mode == "single":
                await self._start_single_mode()
            else:  # multi mode
                await self._start_multi_mode()
            
            self.status = ComponentStatus.RUNNING
            return True
            
        except Exception as e:
            logger.error("Failed to start API service", error=str(e))
            self.status = ComponentStatus.ERROR
            return False
    
    async def _start_single_mode(self):
        """单进程模式启动"""
        config = uvicorn.Config(
            app=self.app,
            host=self.host,
            port=self.port,
            log_level="info"
        )
        self._server = uvicorn.Server(config)
        
        # 在后台任务中运行服务器
        asyncio.create_task(self._server.serve())
        
        # 等待服务器启动
        await self._server.startup()
    
    async def _start_multi_mode(self):
        """多进程模式启动"""
        cmd = [
            "uvicorn", self.app,
            "--host", self.host,
            "--port", str(self.port)
        ]
        
        self._process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            preexec_fn=os.setsid  # 创建新进程组
        )
        
        # 等待进程启动
        await asyncio.sleep(2)
    
    async def stop(self, timeout: int = 30) -> bool:
        """停止API服务"""
        try:
            self.status = ComponentStatus.STOPPING
            
            if self.mode == "single" and self._server:
                await self._server.shutdown()
            elif self.mode == "multi" and self._process:
                await self._stop_process(timeout)
            
            self.status = ComponentStatus.STOPPED
            return True
            
        except Exception as e:
            logger.error("Failed to stop API service", error=str(e))
            return False
    
    async def health_check(self) -> Dict[str, Any]:
        """健康检查"""
        # 实现HTTP健康检查
        return {"status": "healthy", "mode": self.mode}
```

### 步骤3：ApiAdapter多进程模式和进程管理
**测试先行（RED）**：
```python
@pytest.mark.asyncio
async def test_api_adapter_multi_mode_start():
    """测试API适配器多进程模式启动"""
    
    config = {
        "mode": "multi",
        "host": "127.0.0.1", 
        "port": 8001
    }
    
    adapter = ApiAdapter(config)
    
    with patch('asyncio.create_subprocess_exec') as mock_subprocess:
        mock_process = Mock()
        mock_process.returncode = None
        mock_subprocess.return_value = mock_process
        
        result = await adapter.start()
        
        assert result is True
        assert adapter.status == ComponentStatus.RUNNING
        mock_subprocess.assert_called_once()

@pytest.mark.asyncio 
async def test_api_adapter_process_stop_with_timeout():
    """测试进程停止超时处理"""
    
    config = {"mode": "multi"}
    adapter = ApiAdapter(config)
    
    mock_process = Mock()
    mock_process.terminate = AsyncMock()
    mock_process.wait = AsyncMock(side_effect=asyncio.TimeoutError)
    mock_process.kill = AsyncMock()
    adapter._process = mock_process
    
    result = await adapter.stop(timeout=5)
    
    assert result is True
    mock_process.terminate.assert_called_once()
    mock_process.kill.assert_called_once()
```

**最小实现（GREEN）**：
```python
# 添加到 api.py
import os
import signal

async def _stop_process(self, timeout: int):
    """停止进程（优雅停止+强制终止）"""
    if not self._process:
        return
    
    try:
        # 发送SIGTERM信号
        self._process.terminate()
        
        # 等待优雅停止
        try:
            await asyncio.wait_for(self._process.wait(), timeout=timeout)
        except asyncio.TimeoutError:
            # 超时则强制终止
            logger.warning("Process did not terminate gracefully, killing")
            self._process.kill()
            await self._process.wait()
            
    except ProcessLookupError:
        # 进程已结束
        pass
```

### 步骤4：AgentsAdapter实现
**测试先行（RED）**：
```python
# 测试文件：tests/unit/launcher/adapters/test_agents.py
import pytest
from unittest.mock import Mock, patch, AsyncMock
from launcher.adapters.agents import AgentsAdapter

@pytest.mark.asyncio
async def test_agents_adapter_start():
    """测试Agents适配器启动"""
    
    config = {
        "agents": ["worldsmith", "writer"]
    }
    
    adapter = AgentsAdapter(config)
    
    with patch('agents.launcher.AgentLauncher') as mock_launcher_class:
        mock_launcher = Mock()
        mock_launcher.load_agents = Mock()
        mock_launcher.start_all = AsyncMock()
        mock_launcher_class.return_value = mock_launcher
        
        result = await adapter.start()
        
        assert result is True
        mock_launcher.load_agents.assert_called_once_with(["worldsmith", "writer"])
        mock_launcher.start_all.assert_called_once()

@pytest.mark.asyncio
async def test_agents_adapter_stop():
    """测试Agents适配器停止"""
    
    adapter = AgentsAdapter({})
    mock_launcher = Mock()
    mock_launcher.stop_all = AsyncMock()
    adapter._launcher = mock_launcher
    
    result = await adapter.stop()
    
    assert result is True
    mock_launcher.stop_all.assert_called_once()
```

**最小实现（GREEN）**：
```python
# 实现文件：apps/backend/src/launcher/adapters/agents.py
from typing import Dict, Any, List, Optional
from .base import BaseAdapter
from ..types import ComponentStatus
from ...agents.launcher import AgentLauncher
import structlog

logger = structlog.get_logger(__name__)

class AgentsAdapter(BaseAdapter):
    """Agents服务适配器"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__("agents", config)
        self.agent_names: Optional[List[str]] = config.get("agents")
        self._launcher: Optional[AgentLauncher] = None
    
    async def start(self) -> bool:
        """启动Agents服务"""
        try:
            self.status = ComponentStatus.STARTING
            
            # 创建AgentLauncher实例
            self._launcher = AgentLauncher()
            
            # 设置信号处理器
            self._launcher.setup_signal_handlers()
            
            # 加载指定的agents
            self._launcher.load_agents(self.agent_names)
            
            # 启动所有agents
            await self._launcher.start_all()
            
            self.status = ComponentStatus.RUNNING
            return True
            
        except Exception as e:
            logger.error("Failed to start agents", error=str(e))
            self.status = ComponentStatus.ERROR
            return False
    
    async def stop(self, timeout: int = 30) -> bool:
        """停止Agents服务"""
        try:
            self.status = ComponentStatus.STOPPING
            
            if self._launcher:
                await self._launcher.stop_all()
            
            self.status = ComponentStatus.STOPPED
            return True
            
        except Exception as e:
            logger.error("Failed to stop agents", error=str(e))
            return False
    
    async def health_check(self) -> Dict[str, Any]:
        """健康检查"""
        if not self._launcher:
            return {"status": "not_started"}
        
        # 检查agents状态
        agent_status = {}
        for name, agent in self._launcher.agents.items():
            # 假设agent有status属性或方法
            agent_status[name] = "running" if self._launcher.running else "stopped"
        
        return {
            "status": "healthy" if self._launcher.running else "stopped",
            "agents": agent_status,
            "total_agents": len(self._launcher.agents)
        }
```

### 步骤5：适配器集成和类型定义
**测试先行（RED）**：
```python
# 测试文件：tests/unit/launcher/test_types.py
from launcher.types import ComponentStatus, ComponentType

def test_component_status_enum():
    """测试组件状态枚举"""
    assert ComponentStatus.INIT == "init"
    assert ComponentStatus.STARTING == "starting" 
    assert ComponentStatus.RUNNING == "running"
    assert ComponentStatus.STOPPING == "stopping"
    assert ComponentStatus.STOPPED == "stopped"
    assert ComponentStatus.ERROR == "error"

def test_component_type_enum():
    """测试组件类型枚举"""
    assert ComponentType.API == "api"
    assert ComponentType.AGENTS == "agents"
```

**最小实现（GREEN）**：
```python
# 实现文件：apps/backend/src/launcher/types.py（添加内容）
from enum import Enum

class ComponentStatus(Enum):
    """组件状态枚举"""
    INIT = "init"
    STARTING = "starting"
    RUNNING = "running"
    DEGRADED = "degraded" 
    STOPPING = "stopping"
    STOPPED = "stopped"
    ERROR = "error"

class ComponentType(Enum):
    """组件类型枚举"""
    API = "api"
    AGENTS = "agents"
```

**重构优化（REFACTOR）**：
- 完善错误类型定义
- 添加适配器工厂方法
- 统一配置验证逻辑

## 边界情况处理

### 错误场景
1. **服务启动失败**
   - 触发条件：端口被占用、配置错误、依赖不满足
   - 处理方式：记录错误日志，状态设为ERROR，返回false
   - 测试用例：mock端口占用异常，验证错误处理

2. **进程意外终止**
   - 触发条件：OOM、段错误、外部kill
   - 处理方式：通过健康检查检测，状态改为ERROR
   - 测试用例：模拟进程返回码非0的情况

3. **停止超时**
   - 触发条件：服务响应慢或hang住
   - 处理方式：SIGTERM → 等待超时 → SIGKILL
   - 测试用例：mock wait超时，验证强制kill调用

### 性能考虑
- 避免阻塞主事件循环：使用asyncio.create_task
- 批量操作优化：并行启动多个组件
- 资源回收：确保进程和文件句柄正确关闭

## 验收标准

### 功能验收
- [ ] ApiAdapter支持单进程模式（uvicorn服务器）
- [ ] ApiAdapter支持多进程模式（subprocess） 
- [ ] AgentsAdapter能包装现有AgentLauncher
- [ ] 所有适配器实现BaseAdapter接口
- [ ] 支持优雅停止（SIGTERM→SIGKILL）
- [ ] 健康检查功能正常工作

### 技术验收
- [ ] 所有测试通过
- [ ] 代码覆盖率 > 90%
- [ ] 无 linting 错误
- [ ] 类型注解覆盖率 100%
- [ ] 进程资源正确回收

### 集成验收
- [ ] 与现有AgentLauncher兼容
- [ ] 配置模型正确解析
- [ ] 状态枚举定义完整
- [ ] 错误处理机制完善

## 风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| uvicorn单进程模式集成复杂 | 中 | 高 | 参考官方示例，编写专门的集成测试 |
| 进程信号处理跨平台兼容性 | 中 | 中 | 使用os.name判断平台，分别处理 |
| AgentLauncher接口变更 | 低 | 高 | 编写适配器层，隔离变更影响 |
| 内存泄漏或资源未释放 | 中 | 中 | 完善单元测试，使用context manager |

## 实施检查清单

### 开始前
- [ ] 确认任务1-4完成
- [ ] 现有AgentLauncher接口理解清楚
- [ ] 开发环境uvicorn可正常运行

### 实施中
- [ ] 遵循TDD红绿重构流程
- [ ] 每个步骤完成后运行测试
- [ ] 及时提交代码（每个步骤一个commit）
- [ ] 更新相关类型定义

### 完成后
- [ ] 运行完整测试套件
- [ ] 手动测试启动/停止流程
- [ ] 验证进程清理干净
- [ ] 更新任务状态为完成

## 时间估算

| 阶段 | 预计时间 |
|------|----------|
| 技术准备和理解现有代码 | 30分钟 |
| 步骤1：适配器基类 | 60分钟 |
| 步骤2：ApiAdapter单进程模式 | 90分钟 |
| 步骤3：ApiAdapter多进程模式 | 90分钟 |
| 步骤4：AgentsAdapter实现 | 60分钟 |
| 步骤5：类型定义和集成 | 30分钟 |
| 测试完善和边界情况 | 60分钟 |
| 代码优化和重构 | 30分钟 |
| **总计** | 6小时 |

## 审批状态

- [x] 计划已审阅
- [x] 技术方案已确认  
- [x] 准备开始实施

---
*此文档由 spec-task:impl-task-plan 生成，作为任务5实施的详细指导*