# 任务 4 实施计划

生成时间：2025-09-01T23:50:00Z
任务描述：CLI（最小集）- 实现is-launcher命令行接口
关联需求：FR-001, FR-002, NFR-003
预计工时：3小时

## 执行概要

### 目标
实现统一后端启动器的CLI接口，提供up、down、status、logs四个核心命令，支持模式选择、组件过滤和基本操作参数。

### 范围
- **包含**：
  - `is-launcher up` 命令（模式选择、组件过滤、Agent列表、热重载）
  - `is-launcher down` 命令（优雅停止、超时控制）
  - `is-launcher status` 命令（状态查看、监控模式）
  - `is-launcher logs` 命令（组件日志查看）
  - argparse核心解析器架构
  - 命令验证和错误处理
  - 响应时间监控（NFR-003: <100ms）

- **不包含**：
  - 交互式增强特性（rich输出、prompt等）
  - 配置模板系统（FR-006，后续任务）
  - 智能模式推荐（FR-007，后续任务）
  - 实际的服务启动逻辑（Task 5: 适配器层）

### 前置条件
- Task 1（目录与骨架）已完成
- Task 3（启动器配置模型）已完成
- LauncherConfigModel可用
- types.py中的枚举类型定义可用

## 技术准备

### 需要的API/库
| 库/模块 | 方法/类 | 用途 | 文档链接 |
|---------|--------|------|---------|
| argparse | ArgumentParser, add_subparsers | CLI核心解析 | https://docs.python.org/3/library/argparse.html |
| typing | Dict, List, Optional | 类型注解 | https://docs.python.org/3/library/typing.html |
| time | time() | 响应时间监控 | https://docs.python.org/3/library/time.html |
| sys | exit() | CLI退出码 | https://docs.python.org/3/library/sys.html |
| logging | Logger | 错误日志记录 | https://docs.python.org/3/library/logging.html |
| launcher.types | LaunchMode, LauncherStatus | 类型枚举 | 内部模块 |
| launcher.config | LauncherConfigModel | 配置模型 | 内部模块 |

### 代码位置
- **需要创建的文件**：
  - `apps/backend/src/launcher/cli.py` - CLI主入口和解析逻辑
  
- **需要修改的文件**：
  - `apps/backend/pyproject.toml` - 注册console_scripts入口点
  - `apps/backend/src/launcher/__init__.py` - 导出CLI相关类型

## TDD实施步骤

### 步骤1：CLI入口点和基础结构
**测试先行（RED）**：
```python
# 测试文件：tests/launcher/test_cli.py
import pytest
import sys
from unittest.mock import patch
from launcher.cli import main, LauncherCLI

def test_cli_main_entry_point():
    """测试CLI主入口点可以正确调用"""
    with patch('launcher.cli.LauncherCLI') as mock_cli:
        mock_cli.return_value.run.return_value = 0
        result = main()
        mock_cli.assert_called_once()
        mock_cli.return_value.run.assert_called_once()
        assert result == 0

def test_cli_response_time_under_100ms():
    """测试CLI响应时间满足NFR-003要求"""
    import time
    start_time = time.time()
    cli = LauncherCLI()
    cli.setup_parser()
    end_time = time.time()
    response_time = (end_time - start_time) * 1000  # 转为毫秒
    assert response_time < 100, f"CLI响应时间{response_time}ms超过100ms要求"

def test_cli_parser_structure():
    """测试CLI解析器基础结构"""
    cli = LauncherCLI()
    parser = cli.setup_parser()
    
    # 验证主要子命令存在
    subparsers_actions = [action for action in parser._actions if isinstance(action, argparse._SubParsersAction)]
    assert len(subparsers_actions) == 1
    subparsers = subparsers_actions[0]
    assert 'up' in subparsers.choices
    assert 'down' in subparsers.choices  
    assert 'status' in subparsers.choices
    assert 'logs' in subparsers.choices
```

**最小实现（GREEN）**：
```python
# 实现文件：apps/backend/src/launcher/cli.py
import argparse
import sys
import time
from typing import List, Optional
from .types import LaunchMode

class LauncherCLI:
    """统一后端启动器CLI接口
    
    基于argparse的混合架构设计，提供快速响应的核心CLI功能。
    响应时间目标：<100ms (NFR-003)
    """
    
    def __init__(self):
        self.start_time = time.time()
        self.parser = None
    
    def setup_parser(self) -> argparse.ArgumentParser:
        """设置CLI解析器结构"""
        parser = argparse.ArgumentParser(
            prog='is-launcher',
            description='InfiniteScribe统一后端启动器',
            formatter_class=argparse.RawDescriptionHelpFormatter
        )
        
        subparsers = parser.add_subparsers(dest='command', help='可用命令')
        
        # up子命令
        self._setup_up_command(subparsers)
        # down子命令  
        self._setup_down_command(subparsers)
        # status子命令
        self._setup_status_command(subparsers)
        # logs子命令
        self._setup_logs_command(subparsers)
        
        self.parser = parser
        return parser
    
    def _setup_up_command(self, subparsers):
        """设置up子命令"""
        up_parser = subparsers.add_parser('up', help='启动后端服务')
        # 子命令参数将在后续步骤添加
        
    def _setup_down_command(self, subparsers):
        """设置down子命令"""
        down_parser = subparsers.add_parser('down', help='停止后端服务')
        
    def _setup_status_command(self, subparsers):
        """设置status子命令"""
        status_parser = subparsers.add_parser('status', help='查看服务状态')
        
    def _setup_logs_command(self, subparsers):
        """设置logs子命令"""
        logs_parser = subparsers.add_parser('logs', help='查看服务日志')
    
    def run(self, args: Optional[List[str]] = None) -> int:
        """运行CLI，返回退出码"""
        if not self.parser:
            self.setup_parser()
            
        parsed_args = self.parser.parse_args(args)
        
        # 暂时返回成功，实际处理逻辑在后续步骤
        return 0

def main() -> int:
    """CLI主入口点"""
    cli = LauncherCLI()
    return cli.run()

if __name__ == '__main__':
    sys.exit(main())
```

**重构优化（REFACTOR）**：
- 提取常量：命令名称、帮助文本
- 优化导入：按类别分组
- 添加类型注解完整性

### 步骤2：up命令参数解析
**测试先行（RED）**：
```python
def test_up_command_mode_parameter():
    """测试up命令的mode参数"""
    cli = LauncherCLI()
    parser = cli.setup_parser()
    
    # 测试valid modes
    args = parser.parse_args(['up', '--mode', 'single'])
    assert args.command == 'up'
    assert args.mode == 'single'
    
    args = parser.parse_args(['up', '--mode', 'multi'])
    assert args.mode == 'multi'

def test_up_command_components_parameter():
    """测试up命令的components参数"""
    cli = LauncherCLI()
    parser = cli.setup_parser()
    
    # 测试components列表解析
    args = parser.parse_args(['up', '--components', 'api,agents'])
    assert args.components == ['api', 'agents']
    
    args = parser.parse_args(['up', '--components', 'api'])
    assert args.components == ['api']

def test_up_command_agents_parameter():
    """测试up命令的agents参数"""
    cli = LauncherCLI()
    parser = cli.setup_parser()
    
    args = parser.parse_args(['up', '--agents', 'writer,editor,analyzer'])
    assert args.agents == ['writer', 'editor', 'analyzer']
    
    # 测试默认值
    args = parser.parse_args(['up'])
    assert args.agents is None  # 默认所有agents

def test_up_command_reload_flag():
    """测试up命令的reload开关"""
    cli = LauncherCLI()
    parser = cli.setup_parser()
    
    args = parser.parse_args(['up', '--reload'])
    assert args.reload is True
    
    args = parser.parse_args(['up'])
    assert args.reload is False
```

**最小实现（GREEN）**：
```python
def _setup_up_command(self, subparsers):
    """设置up子命令"""
    up_parser = subparsers.add_parser(
        'up', 
        help='启动后端服务',
        description='启动指定的后端服务组件'
    )
    
    # 模式选择
    up_parser.add_argument(
        '--mode',
        choices=['single', 'multi'],
        default='multi',
        help='运行模式：single(单进程)或multi(多进程)，默认multi'
    )
    
    # 组件选择
    up_parser.add_argument(
        '--components',
        type=lambda x: [c.strip() for c in x.split(',')],
        default=['api', 'agents'],
        help='要启动的组件，逗号分隔，如：api,agents'
    )
    
    # Agent选择
    up_parser.add_argument(
        '--agents',
        type=lambda x: [a.strip() for a in x.split(',')],
        default=None,
        help='指定要启动的agent列表，逗号分隔，不指定则启动全部'
    )
    
    # 热重载
    up_parser.add_argument(
        '--reload',
        action='store_true',
        help='开启热重载（仅开发模式）'
    )
```

### 步骤3：down命令参数解析
**测试先行（RED）**：
```python
def test_down_command_grace_parameter():
    """测试down命令的grace超时参数"""
    cli = LauncherCLI()
    parser = cli.setup_parser()
    
    args = parser.parse_args(['down', '--grace', '15'])
    assert args.grace == 15
    
    # 测试默认值
    args = parser.parse_args(['down'])
    assert args.grace == 10  # 默认10秒
```

**最小实现（GREEN）**：
```python
def _setup_down_command(self, subparsers):
    """设置down子命令"""
    down_parser = subparsers.add_parser(
        'down',
        help='停止后端服务',
        description='优雅停止所有运行中的后端服务'
    )
    
    down_parser.add_argument(
        '--grace',
        type=int,
        default=10,
        help='优雅停止等待时间（秒），默认10秒'
    )
```

### 步骤4：status和logs命令参数解析
**测试先行（RED）**：
```python
def test_status_command_watch_parameter():
    """测试status命令的watch参数"""
    cli = LauncherCLI()
    parser = cli.setup_parser()
    
    args = parser.parse_args(['status', '--watch'])
    assert args.watch is True
    
    args = parser.parse_args(['status'])
    assert args.watch is False

def test_logs_command_component_parameter():
    """测试logs命令的component参数"""
    cli = LauncherCLI()
    parser = cli.setup_parser()
    
    args = parser.parse_args(['logs', 'api'])
    assert args.component == 'api'
    
    args = parser.parse_args(['logs', 'agents'])
    assert args.component == 'agents'
```

**最小实现（GREEN）**：
```python
def _setup_status_command(self, subparsers):
    """设置status子命令"""
    status_parser = subparsers.add_parser(
        'status',
        help='查看服务状态',
        description='显示所有服务的当前运行状态'
    )
    
    status_parser.add_argument(
        '--watch',
        action='store_true',
        help='持续监控模式，实时更新状态显示'
    )

def _setup_logs_command(self, subparsers):
    """设置logs子命令"""
    logs_parser = subparsers.add_parser(
        'logs',
        help='查看服务日志',
        description='显示指定组件的日志输出'
    )
    
    logs_parser.add_argument(
        'component',
        choices=['api', 'agents'],
        help='要查看日志的组件名称'
    )
```

### 步骤5：命令处理器和调度逻辑
**测试先行（RED）**：
```python
def test_command_dispatch():
    """测试命令调度逻辑"""
    cli = LauncherCLI()
    
    with patch.object(cli, '_handle_up_command') as mock_up:
        mock_up.return_value = 0
        result = cli.run(['up', '--mode', 'single'])
        mock_up.assert_called_once()
        assert result == 0

def test_invalid_command_handling():
    """测试无效命令处理"""
    cli = LauncherCLI()
    
    with pytest.raises(SystemExit):
        cli.run(['invalid_command'])

def test_parameter_validation():
    """测试参数验证逻辑"""
    cli = LauncherCLI()
    
    # 测试无效的mode
    with pytest.raises(SystemExit):
        cli.run(['up', '--mode', 'invalid_mode'])
    
    # 测试无效的component
    with pytest.raises(SystemExit):
        cli.run(['logs', 'invalid_component'])
```

**最小实现（GREEN）**：
```python
def run(self, args: Optional[List[str]] = None) -> int:
    """运行CLI，返回退出码"""
    if not self.parser:
        self.setup_parser()
        
    try:
        parsed_args = self.parser.parse_args(args)
        
        # 命令调度
        if parsed_args.command == 'up':
            return self._handle_up_command(parsed_args)
        elif parsed_args.command == 'down':
            return self._handle_down_command(parsed_args)
        elif parsed_args.command == 'status':
            return self._handle_status_command(parsed_args)
        elif parsed_args.command == 'logs':
            return self._handle_logs_command(parsed_args)
        else:
            print("错误：未指定命令", file=sys.stderr)
            self.parser.print_help()
            return 1
            
    except Exception as e:
        print(f"错误：{e}", file=sys.stderr)
        return 1

def _handle_up_command(self, args) -> int:
    """处理up命令"""
    # 暂时只打印参数，实际启动逻辑由适配器层实现
    print(f"启动命令：模式={args.mode}, 组件={args.components}, agents={args.agents}, reload={args.reload}")
    return 0

def _handle_down_command(self, args) -> int:
    """处理down命令"""
    print(f"停止命令：grace={args.grace}")
    return 0

def _handle_status_command(self, args) -> int:
    """处理status命令"""
    print(f"状态查询：watch={args.watch}")
    return 0

def _handle_logs_command(self, args) -> int:
    """处理logs命令"""
    print(f"日志查看：component={args.component}")
    return 0
```

### 步骤6：控制台脚本注册和集成测试
**测试先行（RED）**：
```python
def test_console_script_registration():
    """测试控制台脚本注册"""
    import subprocess
    import os
    
    # 如果在开发环境中，测试is-launcher命令可用
    if os.environ.get('TESTING_CLI_INTEGRATION'):
        result = subprocess.run(['is-launcher', '--help'], 
                              capture_output=True, text=True)
        assert result.returncode == 0
        assert 'InfiniteScribe统一后端启动器' in result.stdout

def test_end_to_end_up_command():
    """端到端up命令测试"""
    cli = LauncherCLI()
    result = cli.run(['up', '--mode', 'single', '--components', 'api', '--reload'])
    assert result == 0

def test_end_to_end_down_command():
    """端到端down命令测试"""
    cli = LauncherCLI()
    result = cli.run(['down', '--grace', '5'])
    assert result == 0
```

**最小实现（GREEN）**：
```python
# 修改文件：apps/backend/pyproject.toml
# 在[project]部分添加：
[project.scripts]
is-launcher = "launcher.cli:main"

# 修改文件：apps/backend/src/launcher/__init__.py
from .cli import LauncherCLI, main

__all__ = ['LauncherCLI', 'main']
```

## 边界情况处理

### 错误场景
1. **无效参数组合**
   - 触发条件：--components包含无效组件名
   - 处理方式：argparse自动验证，显示可用选项
   - 测试用例：test_invalid_component_validation()

2. **空参数列表**
   - 触发条件：用户不提供任何命令
   - 处理方式：显示帮助信息并退出
   - 测试用例：test_no_command_shows_help()

3. **解析异常**
   - 触发条件：参数解析过程中的任何异常
   - 处理方式：捕获异常，显示友好错误信息
   - 测试用例：test_parsing_exception_handling()

### 性能考虑
- CLI初始化时间必须<100ms（NFR-003）
- 延迟加载：不在CLI解析阶段加载重型模块
- 参数验证在argparse层面完成，避免额外开销

## 验收标准

### 功能验收
- [ ] `is-launcher up --mode single --components api,agents --agents writer,editor --reload` 正确解析参数
- [ ] `is-launcher down --grace 15` 正确解析参数
- [ ] `is-launcher status --watch` 正确解析参数  
- [ ] `is-launcher logs api` 正确解析参数
- [ ] 无效参数显示清晰错误信息
- [ ] 无命令时显示帮助信息

### 技术验收
- [ ] 所有测试通过
- [ ] 代码覆盖率 > 90%
- [ ] 无 linting 错误
- [ ] 响应时间 < 100ms (NFR-003)

### 集成验收
- [ ] pyproject.toml正确注册console_scripts
- [ ] CLI可通过is-launcher命令调用
- [ ] 参数结构兼容后续适配器层接口

## 风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| argparse复杂参数解析性能 | 低 | 中 | 延迟加载重型验证逻辑 |
| 参数组合验证复杂度 | 中 | 低 | 使用argparse内置验证，避免自定义 |
| CLI API变更影响兼容性 | 低 | 高 | 严格版本化，向后兼容设计 |
| 控制台脚本注册失败 | 低 | 高 | 自动化测试验证，pip install -e . |

## 实施检查清单

### 开始前
- [ ] 确认Task 1、Task 3前置任务完成
- [ ] 确认types.py中枚举类型可用
- [ ] 理解CLI命令结构设计

### 实施中
- [ ] 遵循TDD流程（RED-GREEN-REFACTOR）
- [ ] 每个步骤后运行相关测试
- [ ] 监控响应时间指标
- [ ] 及时提交代码

### 完成后
- [ ] 运行完整测试套件
- [ ] 验证is-launcher命令可用
- [ ] 测试所有参数组合
- [ ] 检查错误处理路径

## 时间估算

| 阶段 | 预计时间 |
|------|----------|
| 技术准备和测试环境 | 20分钟 |
| 步骤1：CLI基础结构 | 45分钟 |
| 步骤2：up命令参数 | 40分钟 |
| 步骤3：down命令参数 | 20分钟 |
| 步骤4：status/logs命令 | 30分钟 |
| 步骤5：命令调度逻辑 | 35分钟 |
| 步骤6：控制台脚本集成 | 25分钟 |
| 测试完善和错误处理 | 20分钟 |
| 代码优化和重构 | 25分钟 |
| **总计** | **3小时** |

## 审批状态

- [ ] 计划已审阅
- [ ] 技术方案已确认  
- [ ] 准备开始实施

---
*此文档由 spec-task:impl-task-plan 生成，作为Task 4详细实施指导*