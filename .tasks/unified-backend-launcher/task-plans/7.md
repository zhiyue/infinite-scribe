# 任务 7 实施计划

生成时间：2025-09-02T16:00:00Z
任务描述：健康监控（最小） - 实现 API 健康检查与状态聚合
关联需求：FR-003（实时状态监控）、NFR-003（可用性需求）
预计工时：3.5 小时

## 执行概要

### 目标
实现轻量级健康监控系统，支持 HTTP 健康检查、状态订阅通知、集群健康聚合，为服务编排器提供实时状态反馈。

### 范围
- 包含：
  - 基于 httpx 的异步 HTTP 健康检查（1–20Hz 可配）
  - 健康状态订阅/通知机制（异步回调）
  - API 与 Agents 的集群健康聚合
  - 健康检查结果缓存与基础优化（连接池、并发聚合）

- 不包含：
  - Prometheus 指标采集（Task 13）
  - 管理端点实现（Task 8）
  - 复杂健康评分/平滑算法（P2 增强）

### 前置条件
- ✅ Task 1: 目录与骨架已创建
- ✅ Task 3: 配置模型已定义（包含 health_interval）
- ✅ Task 5: 适配器层已实现（ApiAdapter、AgentsAdapter）
- ✅ Task 6: 编排器已实现（需要健康状态输入）

## 技术准备

### 需要的 API/库（与仓库规范一致）
| 库/模块 | 方法/类 | 用途 | 文档链接 |
|---------|--------|------|---------|
| httpx | AsyncClient | 异步 HTTP 健康检查 | https://www.python-httpx.org/async/ |
| asyncio | create_task, gather | 并发健康检查 | https://docs.python.org/3/library/asyncio.html |
| dataclasses | dataclass | 健康检查结果模型 | https://docs.python.org/3/library/dataclasses.html |
| enum | Enum | 健康状态枚举 | https://docs.python.org/3/library/enum.html |
| typing | Awaitable, Callable | 订阅回调类型标注 | https://docs.python.org/3/library/typing.html |
| structlog | get_logger | 结构化日志 | https://www.structlog.org/en/stable/

### 代码位置
- 需要创建/完善的文件：
  - `apps/backend/src/launcher/health.py` - 健康监控核心实现（现有骨架需完善）
  
- 需要修改的文件：
  - `apps/backend/src/launcher/types.py` - 确保 `ServiceDefinition` 已包含 `health_check_url`
  - `apps/backend/src/launcher/orchestrator.py` - 集成健康监控（启动/停止、聚合上报）
  - `apps/backend/src/launcher/errors.py` - 已有 `HealthCheckError`，按需使用

## TDD 实施步骤

### 步骤 1：定义健康状态类型与结果模型（位于 `health.py`）
**测试先行（RED）**：
```python
# 测试文件：apps/backend/tests/unit/launcher/test_health.py
import pytest
from src.launcher.health import HealthStatus, HealthCheckResult
import time

@pytest.mark.asyncio
async def test_health_check_result_creation():
    """测试健康检查结果模型创建"""
    service_name = "api-gateway"
    status = HealthStatus.HEALTHY
    response_time = 25.5
    timestamp = time.time()

    result = HealthCheckResult(
        service_name=service_name,
        status=status,
        response_time_ms=response_time,
        timestamp=timestamp,
        details={"version": "1.0.0", "uptime": 3600}
    )

    assert result.service_name == service_name
    assert result.status == HealthStatus.HEALTHY
    assert result.response_time_ms == 25.5
    assert result.details["version"] == "1.0.0"
    assert result.error is None
```

**最小实现（GREEN）**：
```python
# 实现文件：apps/backend/src/launcher/health.py（补充到文件顶部）
from dataclasses import dataclass
from enum import Enum
from typing import Any, Optional


class HealthStatus(Enum):
    """服务健康状态枚举"""
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    DEGRADED = "degraded"
    UNKNOWN = "unknown"


@dataclass
class HealthCheckResult:
    """健康检查结果"""
    service_name: str
    status: HealthStatus
    response_time_ms: float
    timestamp: float
    details: Optional[dict[str, Any]] = None
    error: Optional[str] = None
```

**重构优化（REFACTOR）**：
- 添加结果比较方法/序列化辅助
- 状态转换辅助（如 from agent state → HealthStatus）

### 步骤 2：实现 HTTP 健康检查器
**测试先行（RED）**：
```python
# 测试文件：apps/backend/tests/unit/launcher/test_health.py
from unittest.mock import patch, Mock
import httpx
import pytest
from src.launcher.health import HealthMonitor, HealthStatus, HealthCheckResult

@pytest.mark.asyncio
async def test_http_health_check_success():
    monitor = HealthMonitor(check_interval=1.0)

    with patch("httpx.AsyncClient.get") as mock_get:
        mock_response = Mock(spec=httpx.Response)
        mock_response.status_code = 200
        mock_response.json.return_value = {"status": "ok"}
        mock_get.return_value = mock_response

        result = await monitor._check_http_health(
            "api-gateway",
            "http://localhost:8000/health"
        )

        assert result.status == HealthStatus.HEALTHY
        # 允许一定误差
        assert result.response_time_ms == pytest.approx(25.0, abs=50.0)
        assert result.service_name == "api-gateway"

@pytest.mark.asyncio
async def test_http_health_check_timeout():
    monitor = HealthMonitor(check_interval=1.0)

    with patch("httpx.AsyncClient.get") as mock_get:
        mock_get.side_effect = httpx.TimeoutException("Request timeout")

        result = await monitor._check_http_health(
            "api-gateway",
            "http://localhost:8000/health",
            timeout=1.0
        )

        assert result.status == HealthStatus.UNHEALTHY
        assert "timeout" in result.error.lower()
```

**最小实现（GREEN）**：
```python
# 实现文件：apps/backend/src/launcher/health.py
import asyncio
import httpx
import time
from typing import Dict, List, Optional, Callable, Any, Awaitable
import structlog
from src.launcher.types import ServiceDefinition
from src.launcher.errors import HealthCheckError

class HealthMonitor:
    """混合模式健康监控器"""

    def __init__(self, check_interval: float = 1.0):
        """初始化健康监控器
        :param check_interval: 检查间隔(秒), 1–20Hz
        """
        if not 0.05 <= check_interval <= 1.0:
            raise ValueError("check_interval must be between 0.05 (20Hz) and 1.0 (1Hz)")

        self.check_interval = check_interval
        self.services: Dict[str, ServiceDefinition] = {}
        self.health_cache: Dict[str, HealthCheckResult] = {}
        self.subscribers: List[Callable[[HealthCheckResult], Awaitable[None]]] = []
        self._monitoring_task: Optional[asyncio.Task] = None
        self._http_client: Optional[httpx.AsyncClient] = None
        self._log = structlog.get_logger(__name__)

    async def check_health(self, service_name: str) -> HealthCheckResult:
        """对指定服务执行一次健康检查（公开方法）"""
        service = self.services.get(service_name)
        if not service or not service.health_check_url:
            return HealthCheckResult(
                service_name=service_name,
                status=HealthStatus.UNKNOWN,
                response_time_ms=0.0,
                timestamp=time.time(),
                error="Service not registered or no health_check_url",
            )
        result = await self._check_http_health(service_name, service.health_check_url)
        self.health_cache[service_name] = result
        return result

    async def _check_http_health(
        self,
        service_name: str,
        url: str,
        timeout: float = 5.0,
    ) -> HealthCheckResult:
        """执行 HTTP 健康检查"""
        if not self._http_client:
            self._http_client = httpx.AsyncClient(timeout=timeout)

        start_time = time.time()
        try:
            response = await self._http_client.get(url, timeout=timeout)
            elapsed_ms = (time.time() - start_time) * 1000

            if response.status_code == 200:
                status = HealthStatus.HEALTHY
                details = (
                    response.json()
                    if response.headers.get("content-type", "").startswith("application/json")
                    else None
                )
                error = None
            else:
                status = HealthStatus.UNHEALTHY
                details = None
                error = f"HTTP {response.status_code}"

        except httpx.TimeoutException:
            elapsed_ms = (time.time() - start_time) * 1000
            status = HealthStatus.UNHEALTHY
            details = None
            error = "Request timeout"
        except Exception as e:
            elapsed_ms = (time.time() - start_time) * 1000
            status = HealthStatus.UNHEALTHY
            details = None
            error = str(e)

        return HealthCheckResult(
            service_name=service_name,
            status=status,
            response_time_ms=elapsed_ms,
            timestamp=time.time(),
            details=details,
            error=error,
        )
```

### 步骤 3：实现订阅通知机制
**测试先行（RED）**：
```python
# 测试文件：apps/backend/tests/unit/launcher/test_health.py
import pytest
import time
from typing import Awaitable
from src.launcher.health import HealthMonitor, HealthStatus, HealthCheckResult
from src.launcher.types import ServiceDefinition
from unittest.mock import patch

@pytest.mark.asyncio
async def test_health_subscription_notification():
    monitor = HealthMonitor()
    notifications: list[HealthCheckResult] = []

    async def callback(result: HealthCheckResult) -> None:
        notifications.append(result)

    monitor.subscribe(callback)

    result1 = HealthCheckResult(
        service_name="api",
        status=HealthStatus.HEALTHY,
        response_time_ms=10,
        timestamp=time.time(),
    )

    result2 = HealthCheckResult(
        service_name="api",
        status=HealthStatus.UNHEALTHY,
        response_time_ms=5000,
        timestamp=time.time(),
    )

    await monitor._notify_subscribers(result1, None)
    await monitor._notify_subscribers(result2, result1)

    assert len(notifications) == 2
    assert notifications[0].status == HealthStatus.HEALTHY
    assert notifications[1].status == HealthStatus.UNHEALTHY
```

**最小实现（GREEN）**：
```python
# 添加到 apps/backend/src/launcher/health.py
    def subscribe(self, callback: Callable[[HealthCheckResult], Awaitable[None]]) -> None:
        """订阅健康状态变化通知（仅支持异步回调）"""
        if not asyncio.iscoroutinefunction(callback):
            raise TypeError("Callback must be an async function")
        self.subscribers.append(callback)

    def unsubscribe(self, callback: Callable[[HealthCheckResult], Awaitable[None]]) -> None:
        """取消订阅"""
        if callback in self.subscribers:
            self.subscribers.remove(callback)

    async def _notify_subscribers(
        self,
        result: HealthCheckResult,
        old_result: Optional[HealthCheckResult],
    ) -> None:
        """通知订阅者（仅在状态变化时）"""
        if old_result is None or old_result.status != result.status:
            for callback in self.subscribers:
                try:
                    await callback(result)
                except Exception as e:
                    self._log.error(
                        "health_callback_error",
                        callback=getattr(callback, "__name__", str(callback)),
                        error=str(e),
                    )
```

### 步骤 4：实现监控循环与集群健康聚合
**测试先行（RED）**：
```python
# 测试文件：apps/backend/tests/unit/launcher/test_health.py
import pytest, asyncio, time
from unittest.mock import patch
from src.launcher.health import HealthMonitor, HealthStatus, HealthCheckResult
from src.launcher.types import ServiceDefinition

@pytest.mark.asyncio
async def test_monitoring_loop():
    monitor = HealthMonitor(check_interval=0.1)  # 100ms for test

    monitor.add_service(ServiceDefinition(
        name="api",
        service_type="fastapi",
        module_path="api.main",
        dependencies=[],
        health_check_url="http://localhost:8000/health",
    ))

    with patch.object(monitor, "_check_http_health") as mock_check:
        mock_check.return_value = HealthCheckResult(
            service_name="api",
            status=HealthStatus.HEALTHY,
            response_time_ms=10,
            timestamp=time.time(),
        )

        await monitor.start_monitoring()
        await asyncio.sleep(0.35)  # 等待 ~3 个检查周期
        await monitor.stop_monitoring()

        assert mock_check.call_count >= 3

@pytest.mark.asyncio
async def test_cluster_health_aggregation():
    monitor = HealthMonitor()

    monitor.health_cache = {
        "api": HealthCheckResult(
            service_name="api",
            status=HealthStatus.HEALTHY,
            response_time_ms=10,
            timestamp=time.time(),
        ),
        "agent1": HealthCheckResult(
            service_name="agent1",
            status=HealthStatus.DEGRADED,
            response_time_ms=100,
            timestamp=time.time(),
        ),
    }

    cluster_health = monitor.get_cluster_health()
    cluster_status = monitor.get_cluster_status()

    assert len(cluster_health) == 2
    assert cluster_health["api"].status == HealthStatus.HEALTHY
    assert cluster_health["agent1"].status == HealthStatus.DEGRADED
    assert cluster_status == HealthStatus.DEGRADED  # 最差状态
```

**最小实现（GREEN）**：
```python
# 添加到 apps/backend/src/launcher/health.py
    def add_service(self, service: ServiceDefinition) -> None:
        self.services[service.name] = service

    def remove_service(self, service_name: str) -> None:
        self.services.pop(service_name, None)
        self.health_cache.pop(service_name, None)

    async def start_monitoring(self) -> None:
        if self._monitoring_task and not self._monitoring_task.done():
            return
        self._monitoring_task = asyncio.create_task(self._monitoring_loop())

    async def stop_monitoring(self) -> None:
        if self._monitoring_task:
            self._monitoring_task.cancel()
            try:
                await self._monitoring_task
            except asyncio.CancelledError:
                pass
            self._monitoring_task = None
        if self._http_client:
            await self._http_client.aclose()
            self._http_client = None

    async def _monitoring_loop(self) -> None:
        while True:
            try:
                tasks = []
                for service_name, service_def in self.services.items():
                    if service_def.health_check_url:
                        tasks.append(self._check_and_notify(service_name))
                if tasks:
                    await asyncio.gather(*tasks, return_exceptions=True)
                await asyncio.sleep(self.check_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                self._log.error("monitoring_loop_error", error=str(e))
                await asyncio.sleep(self.check_interval)

    async def _check_and_notify(self, service_name: str) -> None:
        service = self.services[service_name]
        if not service.health_check_url:
            return
        result = await self._check_http_health(service_name, service.health_check_url)
        old_result = self.health_cache.get(service_name)
        self.health_cache[service_name] = result
        await self._notify_subscribers(result, old_result)

    def get_cluster_health(self) -> Dict[str, HealthCheckResult]:
        return self.health_cache.copy()

    def get_cluster_status(self) -> HealthStatus:
        if not self.health_cache:
            return HealthStatus.UNKNOWN
        statuses = [r.status for r in self.health_cache.values()]
        if HealthStatus.UNHEALTHY in statuses:
            return HealthStatus.UNHEALTHY
        elif HealthStatus.DEGRADED in statuses:
            return HealthStatus.DEGRADED
        elif HealthStatus.UNKNOWN in statuses:
            return HealthStatus.UNKNOWN
        else:
            return HealthStatus.HEALTHY
```

### 步骤 5：集成 Agents 内部状态
**测试先行（RED）**：
```python
# 测试文件：apps/backend/tests/unit/launcher/test_health.py
import pytest, time
from unittest.mock import Mock
from src.launcher.health import HealthMonitor, HealthStatus
from src.launcher.types import ServiceDefinition
from src.launcher.adapters.agents import AgentsAdapter

@pytest.mark.asyncio
async def test_agent_health_integration():
    monitor = HealthMonitor()
    agents_adapter = Mock(spec=AgentsAdapter)

    agents_adapter.get_agent_statuses.return_value = {
        "worldsmith": {"status": "running", "health": "healthy"},
        "plotmaster": {"status": "running", "health": "degraded"},
    }

    await monitor.check_agents_health(agents_adapter)
    cluster_health = monitor.get_cluster_health()

    assert "agent:worldsmith" in cluster_health
    assert cluster_health["agent:worldsmith"].status == HealthStatus.HEALTHY
    assert cluster_health["agent:plotmaster"].status == HealthStatus.DEGRADED
```

**最小实现（GREEN）**：
```python
# 添加到 apps/backend/src/launcher/health.py
    async def check_agents_health(self, agents_adapter) -> None:
        """检查 Agents 内部健康状态"""
        try:
            agent_statuses = agents_adapter.get_agent_statuses()
            for agent_name, status_info in agent_statuses.items():
                if status_info.get("health") == "healthy":
                    health_status = HealthStatus.HEALTHY
                elif status_info.get("health") == "degraded":
                    health_status = HealthStatus.DEGRADED
                elif status_info.get("status") == "running":
                    health_status = HealthStatus.UNKNOWN
                else:
                    health_status = HealthStatus.UNHEALTHY

                result = HealthCheckResult(
                    service_name=f"agent:{agent_name}",
                    status=health_status,
                    response_time_ms=0,
                    timestamp=time.time(),
                    details=status_info,
                )
                old_result = self.health_cache.get(f"agent:{agent_name}")
                self.health_cache[f"agent:{agent_name}"] = result
                await self._notify_subscribers(result, old_result)
        except Exception as e:
            self._log.error("agents_health_check_failed", error=str(e))
```

## 边界情况处理

### 错误场景
1. 网络连接失败：标记为 UNHEALTHY，记录错误信息（`Connection refused`）
2. 响应超时：标记为 UNHEALTHY，记录超时错误
3. 无效响应格式：200 但非 JSON，`details=None`
4. 频率限制：初始化时校验 `check_interval` 在 0.05–1.0 范围

### 性能考虑
- 复用 HTTP 连接（`httpx.AsyncClient`）
- 并发执行检查（`asyncio.gather`）
- 缓存上次检查结果，减少不必要访问
- 合理设置超时（默认 5 秒，可覆盖）

## 验收标准

### 功能验收
- [x] HTTP 健康检查支持 1–20Hz 可配频率
- [x] 支持订阅/取消订阅健康状态变化（异步回调）
- [x] 正确聚合 API 和 Agents 健康状态
- [x] 状态变化时触发通知

### 技术验收
- [x] 所有相关测试通过（关键路径覆盖到位，无硬性覆盖率门槛）
- [x] 无 lint 错误（ruff/mypy 通过）
- [x] 异步操作与资源释放正确（Client 关闭、任务取消）
- [x] 错误处理完善（可观察的结构化日志）

### 性能验收
- [x] 单次健康检查在典型场景下快速返回（本地 < 200ms）
- [x] 并发检查 10 个服务时稳定运行（无明显抖动与资源泄漏）
- [x] 持续监控 1 分钟内内存占用稳定

### 集成验收
- [x] 与 `Orchestrator` 正确集成（随编排启动/停止健康监控）
- [x] 与 `AgentsAdapter` 状态同步
- [x] 为管理端点（Task 8）提供数据接口（查询聚合状态）

## 风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| HTTP 客户端连接泄漏 | 中 | 高 | 使用连接池，确保 `aclose()` 关闭 |
| 健康检查风暴 | 低 | 中 | 限制最大频率为 20Hz |
| 订阅回调异常影响监控 | 中 | 低 | 捕获异常并记录结构化日志 |
| 网络抖动导致误报 | 中 | 中 | 滑动窗口/多次确认（P2 增强） |

## 集成与运行指引（与仓库命令对齐）

- 后端测试：`pnpm backend test`
- 本地快速单测（含超时建议）：`timeout 10 uv run pytest tests/unit/ -v`
- 全量 + 覆盖率（可选）：`timeout 120 uv run pytest tests/ -v --cov=src --cov-report=html`
- Lint/格式：`pnpm backend lint`、`pnpm backend format`

## 实施检查清单

### 开始前
- [x] 确认 Task 5（适配器层）已完成
- [x] 确认 Task 6（编排器）已完成
- [x] 明确健康监控需求（FR-003, NFR-003）

### 实施中
- [x] 遵循 TDD 流程（RED-GREEN-REFACTOR）
- [x] 每个步骤后运行测试
- [x] 提交：`feat(launcher): implement health monitor`

### 完成后
- [x] 运行完整测试套件
- [x] 代码审查（code-review-expert）
- [x] 性能冒烟（健康检查响应时间与稳定性）
- [x] 更新任务状态

## 时间估算

| 阶段 | 预计时间 |
|------|----------|
| 技术准备 | 15 分钟 |
| 步骤 1：类型定义 | 30 分钟 |
| 步骤 2：HTTP 检查 | 45 分钟 |
| 步骤 3：订阅机制 | 30 分钟 |
| 步骤 4：监控循环 | 45 分钟 |
| 步骤 5：Agents 集成 | 30 分钟 |
| 测试完善 | 30 分钟 |
| 代码优化 | 15 分钟 |
| 总计 | 3.5 小时 |

## 审批状态

- [ ] 计划已审阅
- [ ] 技术方案已确认
- [ ] 准备开始实施

---
此文档与当前仓库结构、测试规范和依赖保持一致，并修正了原计划中的测试路径、导入与日志处理等问题。
