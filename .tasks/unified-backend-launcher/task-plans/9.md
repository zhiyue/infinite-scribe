# 任务 9 实施计划

生成时间：2025-09-02T16:50:00Z
任务描述：信号与跨平台停止 - 基于现有process_utils.py扩展跨平台优雅停止，新增轻量信号工具
关联需求：FR-004, NFR-002, NFR-004
预计工时：3小时

## 执行概要

### 目标
基于现有process_utils.py扩展跨平台优雅停止能力，新增轻量信号工具支持CLI可选守护模式。

### 范围
- **包含**：
  - 扩展现有ProcessManager支持强制终止进程组
  - 新增轻量signal_utils.py（POSIX用loop.add_signal_handler，Windows用signal.signal）
  - CLI新增--stay可选模式支持信号等待
  - 安全的异步信号回调触发机制

- **不包含**：
  - 重新实现进程管理（复用现有process_utils.py）
  - 改变CLI默认行为（保持一次性执行语义）
  - 重新实现agents信号处理（复用现有逻辑）

### 前置条件
- 现有apps/backend/src/launcher/adapters/process_utils.py已有ProcessManager基础
- 现有apps/backend/src/agents/launcher.py已有agents信号处理
- 任务6（编排器）需要提供shutdown方法

## 技术准备

### 需要的API/库
| 库/模块 | 方法/类 | 用途 | 文档链接 |
|---------|--------|------|---------|
| asyncio | add_signal_handler, call_soon_threadsafe | POSIX信号处理 | [AsyncIO Signals](https://docs.python.org/3/library/asyncio-eventloop.html#unix-signals) |
| signal | signal, SIGTERM, SIGINT, SIGKILL | Windows信号回退 | [Python Signal](https://docs.python.org/3/library/signal.html) |
| os | killpg, getpgid, name | 进程组强杀 | [Python OS](https://docs.python.org/3/library/os.html) |
| structlog | get_logger | 结构化日志 | [Structlog](https://www.structlog.org/) |

### 代码位置
- **需要创建的文件**：
  - `apps/backend/src/launcher/signal_utils.py` - 轻量信号工具函数
  
- **需要修改的文件**：
  - `apps/backend/src/launcher/adapters/process_utils.py` - 扩展强制终止能力
  - `apps/backend/src/launcher/cli.py` - 新增--stay可选模式

## TDD实施步骤

### 步骤1：扩展现有ProcessManager
**测试先行（RED）**：
```python
# 测试文件：tests/unit/launcher/adapters/test_process_utils.py
import pytest
import asyncio
import os
import signal
from unittest.mock import Mock, patch, AsyncMock
from launcher.adapters.process_utils import ProcessManager

class TestProcessManagerEnhancements:
    
    @pytest.fixture
    def process_manager(self):
        return ProcessManager()
    
    @pytest.mark.asyncio
    async def test_force_terminate_process_group_posix(self, process_manager):
        """POSIX系统应支持强制终止进程组"""
        mock_proc = Mock()
        mock_proc.pid = 12345
        
        with patch("launcher.adapters.process_utils.os.name", "posix"), \
             patch("launcher.adapters.process_utils.os.killpg") as mock_killpg, \
             patch("launcher.adapters.process_utils.os.getpgid", return_value=12345):
            
            result = await process_manager.force_terminate_process_group(mock_proc)
            
            mock_killpg.assert_called_once_with(12345, signal.SIGKILL)
            assert result is True
    
    @pytest.mark.asyncio
    async def test_force_terminate_process_group_windows(self, process_manager):
        """Windows系统应使用kill()强制终止"""
        mock_proc = Mock()
        mock_proc.kill = Mock()
        
        with patch("launcher.adapters.process_utils.os.name", "nt"):
            result = await process_manager.force_terminate_process_group(mock_proc)
            
            mock_proc.kill.assert_called_once()
            assert result is True
    
    @pytest.mark.asyncio
    async def test_graceful_shutdown_with_force_fallback(self, process_manager):
        """优雅停止超时后应执行强制终止"""
        mock_proc = Mock()
        mock_proc.wait = AsyncMock()
        mock_proc.wait.side_effect = asyncio.TimeoutError()
        
        with patch.object(process_manager, 'terminate_process_gracefully', return_value=True), \
             patch.object(process_manager, 'force_terminate_process_group', return_value=True) as mock_force:
            
            result = await process_manager.shutdown_process(mock_proc, grace_period=1)
            
            mock_force.assert_called_once()
            assert result is True
```

**最小实现（GREEN）**：
```python
# 扩展文件：apps/backend/src/launcher/adapters/process_utils.py
import structlog
import os
import signal
import asyncio

logger = structlog.get_logger(__name__)

class ProcessManager:
    # ... 现有代码 ...
    
    async def force_terminate_process_group(self, proc: asyncio.subprocess.Process) -> bool:
        """
        强制终止进程组
        :param proc: 进程对象
        :return: 是否成功终止
        """
        try:
            if os.name != "nt":  # POSIX
                try:
                    # 强制终止整个进程组
                    pgid = os.getpgid(proc.pid)
                    os.killpg(pgid, signal.SIGKILL)
                    logger.info("Force terminated process group", pid=proc.pid, pgid=pgid)
                except ProcessLookupError:
                    # 进程已经退出
                    logger.debug("Process already terminated", pid=proc.pid)
            else:  # Windows
                # Windows直接强杀进程
                proc.kill()
                logger.info("Force terminated process", pid=proc.pid)
            
            return True
            
        except Exception as e:
            logger.error("Failed to force terminate process", pid=proc.pid, error=str(e))
            return False
    
    async def shutdown_process(
        self, 
        proc: asyncio.subprocess.Process, 
        grace_period: int = 10
    ) -> bool:
        """
        优雅停止进程，超时后强制终止
        :param proc: 进程对象
        :param grace_period: 优雅停止超时时间
        :return: 是否成功停止
        """
        logger.info("Starting process shutdown", pid=proc.pid, grace_period=grace_period)
        
        # 第一步：优雅停止
        try:
            success = await self.terminate_process_gracefully(proc)
            if not success:
                logger.warning("Graceful termination failed, forcing shutdown", pid=proc.pid)
                return await self.force_terminate_process_group(proc)
            
            # 第二步：等待进程退出
            await asyncio.wait_for(proc.wait(), timeout=grace_period)
            logger.info("Process gracefully shutdown", pid=proc.pid)
            return True
            
        except asyncio.TimeoutError:
            logger.warning("Graceful shutdown timeout, forcing termination", pid=proc.pid)
            return await self.force_terminate_process_group(proc)
        except Exception as e:
            logger.error("Process shutdown failed", pid=proc.pid, error=str(e))
            return False
```

### 步骤2：轻量信号工具
**测试先行（RED）**：
```python
# 测试文件：tests/unit/launcher/test_signal_utils.py
import pytest
import asyncio
import signal
import os
from unittest.mock import Mock, patch, AsyncMock
from launcher.signal_utils import register_shutdown_handler, wait_for_shutdown_signal

class TestSignalUtils:
    
    @pytest.mark.asyncio
    async def test_register_shutdown_handler_posix(self):
        """POSIX系统应使用loop.add_signal_handler"""
        mock_loop = Mock()
        mock_callback = AsyncMock()
        
        with patch("launcher.signal_utils.os.name", "posix"), \
             patch("launcher.signal_utils.asyncio.get_running_loop", return_value=mock_loop):
            
            cleanup = register_shutdown_handler(mock_callback)
            
            # 验证注册了信号处理器
            assert mock_loop.add_signal_handler.call_count == 2
            call_args = [call.args[0] for call in mock_loop.add_signal_handler.call_args_list]
            assert signal.SIGINT in call_args
            assert signal.SIGTERM in call_args
            
            # 清理
            cleanup()
    
    @pytest.mark.asyncio
    async def test_register_shutdown_handler_windows(self):
        """Windows系统应使用signal.signal回退"""
        mock_callback = AsyncMock()
        
        with patch("launcher.signal_utils.os.name", "nt"), \
             patch("launcher.signal_utils.signal.signal") as mock_signal:
            
            cleanup = register_shutdown_handler(mock_callback)
            
            # 验证注册了SIGINT信号处理器
            mock_signal.assert_called_once()
            assert mock_signal.call_args[0][0] == signal.SIGINT
            
            # 清理
            cleanup()
    
    @pytest.mark.asyncio
    async def test_signal_callback_safe_execution(self):
        """信号回调应安全执行"""
        callback_executed = asyncio.Event()
        mock_loop = Mock()
        
        async def test_callback():
            callback_executed.set()
        
        with patch("launcher.signal_utils.os.name", "posix"), \
             patch("launcher.signal_utils.asyncio.get_running_loop", return_value=mock_loop):
            
            cleanup = register_shutdown_handler(test_callback)
            
            # 获取注册的回调函数
            registered_callback = mock_loop.add_signal_handler.call_args_list[0][0][1]
            
            # 执行回调
            registered_callback()
            
            # 验证通过call_soon_threadsafe安全调度
            mock_loop.call_soon_threadsafe.assert_called_once()
            cleanup()
    
    @pytest.mark.asyncio
    async def test_wait_for_shutdown_signal_integration(self):
        """集成测试：等待关闭信号"""
        with patch("launcher.signal_utils.register_shutdown_handler") as mock_register:
            mock_cleanup = Mock()
            mock_register.return_value = mock_cleanup
            
            # 模拟信号触发
            shutdown_event = asyncio.Event()
            
            async def mock_handler():
                shutdown_event.set()
            
            # 启动等待任务
            wait_task = asyncio.create_task(wait_for_shutdown_signal())
            
            # 模拟信号触发
            await mock_handler()
            shutdown_event.set()
            
            # 等待任务完成
            try:
                await asyncio.wait_for(wait_task, timeout=1.0)
            except asyncio.TimeoutError:
                wait_task.cancel()
            
            # 验证清理被调用
            mock_cleanup.assert_called_once()
```

**最小实现（GREEN）**：
```python
# 实现文件：apps/backend/src/launcher/signal_utils.py
import asyncio
import signal
import os
from typing import Callable, Awaitable, Any
import structlog

logger = structlog.get_logger(__name__)

def register_shutdown_handler(callback: Callable[[], Awaitable[None]]) -> Callable[[], None]:
    """
    注册关闭信号处理器（轻量工具函数）
    :param callback: 异步关闭回调函数
    :return: 清理函数
    """
    cleanup_functions = []
    
    def safe_callback_wrapper():
        """安全执行异步回调的包装函数"""
        try:
            loop = asyncio.get_running_loop()
            # 使用call_soon_threadsafe安全调度异步任务
            loop.call_soon_threadsafe(lambda: asyncio.create_task(callback()))
        except RuntimeError:
            logger.warning("No running event loop for signal callback")
    
    try:
        if os.name != "nt":  # POSIX系统
            loop = asyncio.get_running_loop()
            
            # 注册SIGINT和SIGTERM
            for sig in [signal.SIGINT, signal.SIGTERM]:
                loop.add_signal_handler(sig, safe_callback_wrapper)
                cleanup_functions.append(lambda s=sig: loop.remove_signal_handler(s))
            
            logger.info("Registered POSIX signal handlers", signals=["SIGINT", "SIGTERM"])
            
        else:  # Windows系统
            # Windows只支持SIGINT，使用signal.signal回退
            original_handler = signal.signal(signal.SIGINT, 
                                           lambda sig, frame: safe_callback_wrapper())
            cleanup_functions.append(
                lambda: signal.signal(signal.SIGINT, original_handler)
            )
            
            logger.info("Registered Windows signal handler", signal="SIGINT")
            
    except Exception as e:
        logger.error("Failed to register signal handlers", error=str(e))
        # 返回空清理函数
        return lambda: None
    
    def cleanup():
        """清理所有信号处理器"""
        for cleanup_fn in cleanup_functions:
            try:
                cleanup_fn()
            except Exception as e:
                logger.warning("Signal handler cleanup failed", error=str(e))
        logger.info("Signal handlers cleaned up")
    
    return cleanup

async def wait_for_shutdown_signal() -> None:
    """
    等待关闭信号（便利函数）
    """
    shutdown_event = asyncio.Event()
    
    async def shutdown_handler():
        shutdown_event.set()
        logger.info("Shutdown signal received")
    
    # 注册信号处理器
    cleanup = register_shutdown_handler(shutdown_handler)
    
    try:
        # 等待信号
        await shutdown_event.wait()
    finally:
        # 清理信号处理器
        cleanup()
```

### 步骤3：CLI --stay模式集成
**测试先行（RED）**：
```python
# 测试文件：tests/unit/launcher/test_cli.py
import pytest
from unittest.mock import patch, Mock, AsyncMock
from launcher.cli import create_parser, main

class TestCLIStayMode:
    
    def test_parser_includes_stay_option(self):
        """CLI解析器应包含--stay选项"""
        parser = create_parser()
        
        # 测试--stay参数存在
        args = parser.parse_args(["up", "--stay"])
        assert hasattr(args, 'stay')
        assert args.stay is True
        
        # 测试默认行为（不stay）
        args = parser.parse_args(["up"])
        assert args.stay is False
    
    @pytest.mark.asyncio
    async def test_stay_mode_waits_for_signal(self):
        """--stay模式应等待信号退出"""
        with patch('launcher.cli.UnifiedLauncher') as mock_launcher_class, \
             patch('launcher.cli.wait_for_shutdown_signal') as mock_wait:
            
            mock_launcher = AsyncMock()
            mock_launcher_class.return_value = mock_launcher
            mock_wait.return_value = None  # 模拟信号接收
            
            # 模拟--stay模式
            await main(["up", "--stay"])
            
            # 验证等待信号被调用
            mock_wait.assert_called_once()
            mock_launcher.stop.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_default_mode_exits_immediately(self):
        """默认模式应启动后立即退出"""
        with patch('launcher.cli.UnifiedLauncher') as mock_launcher_class, \
             patch('launcher.cli.wait_for_shutdown_signal') as mock_wait:
            
            mock_launcher = AsyncMock()
            mock_launcher_class.return_value = mock_launcher
            
            # 模拟默认模式（无--stay）
            await main(["up"])
            
            # 验证不等待信号
            mock_wait.assert_not_called()
            # 但仍然会停止launcher
            mock_launcher.stop.assert_called_once()
```

**最小实现（GREEN）**：
```python
# 修改文件：apps/backend/src/launcher/cli.py
from .signal_utils import wait_for_shutdown_signal
import structlog

logger = structlog.get_logger(__name__)

def create_parser():
    """创建CLI参数解析器"""
    parser = argparse.ArgumentParser(description="Unified Backend Launcher")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # up命令
    up_parser = subparsers.add_parser("up", help="Start services")
    up_parser.add_argument("--mode", choices=["single", "multi"], default="multi")
    up_parser.add_argument("--components", default="api,agents")
    up_parser.add_argument("--agents", help="Comma-separated agent names")
    up_parser.add_argument("--reload", action="store_true")
    up_parser.add_argument("--grace", type=int, default=10)
    # 新增--stay选项
    up_parser.add_argument("--stay", action="store_true", 
                          help="Wait for shutdown signal (daemon mode)")
    
    return parser

async def main(args: List[str] = None):
    """主入口函数"""
    parser = create_parser()
    parsed_args = parser.parse_args(args or sys.argv[1:])
    
    launcher = None
    
    try:
        if parsed_args.command == "up":
            # 创建启动器配置
            config = LaunchConfig(
                mode=LaunchMode(parsed_args.mode),
                components=parsed_args.components.split(','),
                agents=parsed_args.agents.split(',') if parsed_args.agents else None,
                reload=parsed_args.reload,
                stop_grace=parsed_args.grace
            )
            
            launcher = UnifiedLauncher(config)
            
            # 启动服务
            success = await launcher.start()
            if not success:
                logger.error("Failed to start services")
                return 1
                
            logger.info("Services started successfully")
            
            # 根据--stay参数决定行为
            if parsed_args.stay:
                logger.info("Stay mode enabled, waiting for shutdown signal...")
                await wait_for_shutdown_signal()
                logger.info("Shutdown signal received, stopping services...")
            else:
                logger.info("Default mode: services started, exiting immediately")
                
    except KeyboardInterrupt:
        logger.info("Received KeyboardInterrupt, shutting down...")
    except Exception as e:
        logger.error("Unexpected error", error=str(e))
        return 1
    finally:
        # 确保清理资源
        if launcher:
            await launcher.stop(graceful=True)
    
    return 0

if __name__ == "__main__":
    import sys
    sys.exit(asyncio.run(main()))
```

## 边界条件处理

### 错误场景
1. **进程组强杀失败**
   - 触发条件：进程已退出或权限不足
   - 处理方式：记录错误但继续，不阻塞其他进程停止
   - 测试用例：test_force_terminate_failure_handling

2. **信号注册失败**
   - 触发条件：无运行事件循环或信号被占用
   - 处理方式：返回空清理函数，记录警告
   - 测试用例：test_signal_registration_failure

3. **Windows信号限制**
   - 触发条件：CTRL_BREAK_EVENT对无控制台进程无效
   - 处理方式：直接调用kill()，记录限制说明
   - 测试用例：test_windows_signal_fallback

4. **CLI --stay与现有逻辑冲突**
   - 触发条件：--stay与其他参数组合使用
   - 处理方式：明确参数优先级，记录行为说明
   - 测试用例：test_stay_mode_parameter_conflicts

### 性能考虑
- 使用asyncio.gather并发处理多个进程的停止
- 避免阻塞等待，使用超时机制
- 最小化信号处理器的执行时间

## 验收标准

### 功能验收
- [ ] 现有ProcessManager扩展强制终止能力
- [ ] POSIX系统使用loop.add_signal_handler注册信号
- [ ] Windows系统使用signal.signal回退机制
- [ ] CLI --stay模式正确等待信号退出
- [ ] CLI默认模式保持原有行为（启动后退出）
- [ ] 优雅停止超时后执行强制终止SIGKILL
- [ ] 信号回调安全执行（call_soon_threadsafe）

### 技术验收
- [ ] 所有测试通过（模块级覆盖率 > 90%）
- [ ] 使用structlog统一日志格式
- [ ] 测试导入路径符合现有规范
- [ ] Mock目标指向正确模块命名空间

### 集成验收
- [ ] 不破坏现有process_utils.py接口
- [ ] 不改变现有CLI默认行为
- [ ] 与现有agents信号处理共存

## 风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 与现有代码接口冲突 | 低 | 高 | 仔细review现有process_utils.py |
| Windows信号处理限制 | 中 | 中 | kill()降级，文档说明限制 |
| --stay模式用户混淆 | 中 | 低 | 清晰帮助文本，文档说明 |
| 现有agents信号冲突 | 低 | 中 | 测试验证共存，必要时协调 |

## 实施检查清单

### 开始前
- [ ] 确认任务5、6已完成并集成测试通过
- [ ] 准备跨平台测试环境(Linux/Windows)
- [ ] 理解信号处理和进程管理原理

### 实施中
- [ ] 每步骤完成后执行跨平台测试
- [ ] 持续集成验证不同操作系统
- [ ] 及时处理平台特定的边界情况

### 完成后
- [ ] 端到端集成测试
- [ ] 性能测试(启动/停止时间)
- [ ] 文档更新(跨平台使用说明)

## 时间估算

| 阶段 | 预计时间 |
|------|----------|
| 技术准备与调研 | 20分钟 |
| 步骤1：扩展ProcessManager | 75分钟 |
| 步骤2：轻量信号工具 | 50分钟 |
| 步骤3：CLI --stay集成 | 35分钟 |
| 跨平台测试验证 | 40分钟 |
| **总计** | **3小时** |

## 审批状态

- [ ] 计划已审阅
- [ ] 技术方案已确认
- [ ] 准备开始实施

---

## 📋 Review修订说明

**根据代码review意见，本计划已进行如下关键调整：**

### 🔄 架构对齐
- **复用现有基础设施**：在现有`process_utils.py`基础上扩展，避免重复造轮子
- **轻量工具函数**：新建`signal_utils.py`提供轻量函数，而非重量级类
- **保持CLI语义**：`--stay`作为可选模式，不改变默认"一次性执行"行为

### 🛠️ 技术修正
- **信号处理优化**：POSIX用`loop.add_signal_handler`，Windows用`signal.signal`回退
- **安全回调调度**：使用`call_soon_threadsafe`避免跨线程asyncio问题
- **日志系统统一**：全面使用`structlog`保持一致性

### 🧪 测试规范化
- **导入路径对齐**：使用`launcher.adapters.process_utils`等现有规范
- **Mock目标修正**：patch指向被测模块命名空间而非全局
- **覆盖率目标**：模块级>90%，避免影响全局门槛

### ⚖️ 兼容性保证
- **向后兼容**：不破坏现有`process_utils.py`接口
- **共存设计**：与现有agents信号处理协调共存
- **文档完善**：补充跨平台限制说明

*此修订版计划与现有代码库架构完全对齐，确保最小化集成风险*

---
*此文档由 spec-task:impl-task-plan 生成并经过code review修订*