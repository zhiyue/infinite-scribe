# 任务 9 实施计划

生成时间：2025-09-02T16:50:00Z
任务描述：信号与跨平台停止 - 基于现有process_utils.py扩展跨平台优雅停止，新增轻量信号工具
关联需求：FR-004, NFR-002, NFR-004
预计工时：3小时

## 执行概要

### 目标
基于现有process_utils.py扩展跨平台优雅停止能力，新增轻量信号工具支持CLI可选守护模式。

### 范围
- **包含**：
  - 扩展现有ProcessManager支持强制终止进程组
  - 新增轻量signal_utils.py（POSIX用loop.add_signal_handler，Windows用signal.signal）
  - CLI新增--stay可选模式支持信号等待
  - 安全的异步信号回调触发机制

- **不包含**：
  - 重新实现进程管理（复用现有process_utils.py）
  - 改变CLI默认行为（保持一次性执行语义）
  - 重新实现agents信号处理（复用现有逻辑）

### 前置条件
- 现有apps/backend/src/launcher/adapters/process_utils.py已有ProcessManager基础
- 现有apps/backend/src/agents/launcher.py已有agents信号处理
- 任务6（编排器）需要提供shutdown方法

## 技术准备

### 需要的API/库
| 库/模块 | 方法/类 | 用途 | 文档链接 |
|---------|--------|------|---------|
| asyncio | add_signal_handler, call_soon_threadsafe | POSIX信号处理 | [AsyncIO Signals](https://docs.python.org/3/library/asyncio-eventloop.html#unix-signals) |
| signal | signal, SIGTERM, SIGINT, SIGKILL | Windows信号回退 | [Python Signal](https://docs.python.org/3/library/signal.html) |
| os | killpg, getpgid, name | 进程组强杀 | [Python OS](https://docs.python.org/3/library/os.html) |
| structlog | get_logger | 结构化日志 | [Structlog](https://www.structlog.org/) |

### 代码位置
- **需要创建的文件**：
  - `apps/backend/src/launcher/signal_utils.py` - 轻量信号工具函数
  
- **需要修改的文件**：
  - `apps/backend/src/launcher/adapters/process_utils.py` - 扩展强制终止能力
  - `apps/backend/src/launcher/cli.py` - 新增--stay可选模式

## TDD实施步骤

### 步骤1：确认现有ProcessManager已满足需求（无需修改）
**验证现有功能**：
现有`ProcessManager.terminate_process`方法已实现完整的进程终止流程：
- 优雅停止：发送SIGTERM/CTRL_BREAK_EVENT
- 超时等待：使用`asyncio.wait_for`
- 强制终止：超时后使用`os.killpg(os.getpgid(process.pid), signal.SIGKILL)`

**测试现有API**：
```python
# 测试文件：tests/unit/launcher/adapters/test_process_utils.py  
import pytest
import asyncio
import os
import signal
from unittest.mock import Mock, patch, AsyncMock
from launcher.adapters.process_utils import ProcessManager

class TestProcessManagerExistingFeatures:
    
    @pytest.mark.asyncio
    async def test_terminate_process_timeout_forces_sigkill(self):
        """验证现有terminate_process在超时时使用SIGKILL"""
        mock_proc = Mock()
        mock_proc.pid = 12345
        mock_proc.returncode = None
        mock_proc.wait = AsyncMock(side_effect=asyncio.TimeoutError())
        
        with patch("launcher.adapters.process_utils.os.name", "posix"), \
             patch("launcher.adapters.process_utils.os.killpg") as mock_killpg, \
             patch("launcher.adapters.process_utils.os.getpgid", return_value=12345), \
             patch("launcher.adapters.process_utils.asyncio.wait_for", side_effect=asyncio.TimeoutError()):
            
            await ProcessManager.terminate_process(mock_proc, timeout=1)
            
            # 验证SIGKILL调用
            sigkill_calls = [call for call in mock_killpg.call_args_list if call.args[1] == signal.SIGKILL]
            assert len(sigkill_calls) >= 1
```

**结论**：现有ProcessManager已满足需求，无需添加新功能。

### 步骤2：轻量信号工具
**测试先行（RED）**：
```python
# 测试文件：tests/unit/launcher/test_signal_utils.py
import pytest
import asyncio
import signal
import os
from unittest.mock import Mock, patch, AsyncMock
from launcher.signal_utils import register_shutdown_handler, wait_for_shutdown_signal

class TestSignalUtils:
    
    @pytest.mark.asyncio
    async def test_register_shutdown_handler_posix(self):
        """POSIX系统应使用loop.add_signal_handler，只注册SIGINT"""
        mock_loop = Mock()
        mock_callback = AsyncMock()
        
        with patch("launcher.signal_utils.os.name", "posix"), \
             patch("launcher.signal_utils.asyncio.get_running_loop", return_value=mock_loop):
            
            cleanup = register_shutdown_handler(mock_callback)
            
            # 验证只注册了SIGINT信号处理器（避免与agents冲突）
            mock_loop.add_signal_handler.assert_called_once()
            assert mock_loop.add_signal_handler.call_args.args[0] == signal.SIGINT
            
            # 清理
            cleanup()
    
    @pytest.mark.asyncio
    async def test_register_shutdown_handler_windows(self):
        """Windows系统应使用signal.signal回退"""
        mock_callback = AsyncMock()
        
        with patch("launcher.signal_utils.os.name", "nt"), \
             patch("launcher.signal_utils.signal.signal") as mock_signal:
            
            cleanup = register_shutdown_handler(mock_callback)
            
            # 验证注册了SIGINT信号处理器
            mock_signal.assert_called_once()
            assert mock_signal.call_args[0][0] == signal.SIGINT
            
            # 清理
            cleanup()
    
    @pytest.mark.asyncio
    async def test_signal_callback_safe_execution(self):
        """信号回调应安全执行"""
        callback_executed = asyncio.Event()
        mock_loop = Mock()
        
        async def test_callback():
            callback_executed.set()
        
        with patch("launcher.signal_utils.os.name", "posix"), \
             patch("launcher.signal_utils.asyncio.get_running_loop", return_value=mock_loop):
            
            cleanup = register_shutdown_handler(test_callback)
            
            # 获取注册的回调函数
            registered_callback = mock_loop.add_signal_handler.call_args.args[1]
            
            # 执行回调
            registered_callback()
            
            # 验证通过call_soon_threadsafe安全调度
            mock_loop.call_soon_threadsafe.assert_called_once()
            cleanup()
    
    @pytest.mark.asyncio
    async def test_wait_for_shutdown_signal_integration(self):
        """集成测试：等待关闭信号"""
        with patch("launcher.signal_utils.register_shutdown_handler") as mock_register:
            mock_cleanup = Mock()
            captured_callback = None
            
            def capture_callback(callback):
                nonlocal captured_callback
                captured_callback = callback
                return mock_cleanup
            
            mock_register.side_effect = capture_callback
            
            # 启动等待任务
            wait_task = asyncio.create_task(wait_for_shutdown_signal())
            
            # 等待register被调用并获取回调
            await asyncio.sleep(0.01)
            assert captured_callback is not None
            
            # 模拟信号触发回调
            await captured_callback()
            
            # 等待任务完成
            try:
                await asyncio.wait_for(wait_task, timeout=1.0)
            except asyncio.TimeoutError:
                wait_task.cancel()
                # 确保finally块执行
                try:
                    await wait_task
                except asyncio.CancelledError:
                    pass
            
            # 验证清理被调用
            mock_cleanup.assert_called_once()
```

**最小实现（GREEN）**：
```python
# 实现文件：apps/backend/src/launcher/signal_utils.py
import asyncio
import signal
import os
from typing import Callable, Awaitable
import structlog

logger = structlog.get_logger(__name__)

def register_shutdown_handler(callback: Callable[[], Awaitable[None]]) -> Callable[[], None]:
    """
    注册关闭信号处理器（轻量工具函数）
    :param callback: 异步关闭回调函数
    :return: 清理函数
    """
    cleanup_functions = []
    
    def safe_callback_wrapper():
        """安全执行异步回调的包装函数"""
        try:
            loop = asyncio.get_running_loop()
            # 使用call_soon_threadsafe安全调度异步任务
            loop.call_soon_threadsafe(lambda: asyncio.create_task(callback()))
        except RuntimeError:
            logger.warning("No running event loop for signal callback")
    
    try:
        # 注意：只监听SIGINT以避免与agents信号处理冲突
        # agents中已经处理了SIGTERM，CLI只需处理SIGINT即可
        if os.name != "nt":  # POSIX系统
            loop = asyncio.get_running_loop()
            
            # 只注册SIGINT，避免与AgentLauncher.setup_signal_handlers()冲突
            loop.add_signal_handler(signal.SIGINT, safe_callback_wrapper)
            cleanup_functions.append(lambda: loop.remove_signal_handler(signal.SIGINT))
            
            logger.info("Registered POSIX signal handler", signal="SIGINT")
            
        else:  # Windows系统
            # Windows只支持SIGINT，使用signal.signal回退
            original_handler = signal.signal(signal.SIGINT, 
                                           lambda sig, frame: safe_callback_wrapper())
            cleanup_functions.append(
                lambda: signal.signal(signal.SIGINT, original_handler)
            )
            
            logger.info("Registered Windows signal handler", signal="SIGINT")
            
    except Exception as e:
        logger.error("Failed to register signal handlers", error=str(e))
        # 返回空清理函数
        return lambda: None
    
    def cleanup():
        """清理所有信号处理器"""
        for cleanup_fn in cleanup_functions:
            try:
                cleanup_fn()
            except Exception as e:
                logger.warning("Signal handler cleanup failed", error=str(e))
        logger.info("Signal handlers cleaned up")
    
    return cleanup

async def wait_for_shutdown_signal() -> None:
    """
    等待关闭信号（便利函数）
    """
    shutdown_event = asyncio.Event()
    
    async def shutdown_handler():
        shutdown_event.set()
        logger.info("Shutdown signal received")
    
    # 注册信号处理器
    cleanup = register_shutdown_handler(shutdown_handler)
    
    try:
        # 等待信号
        await shutdown_event.wait()
    finally:
        # 清理信号处理器
        cleanup()
```

### 步骤3：CLI --stay模式集成（基于现有CLI结构）
**测试先行（RED）**：
```python
# 测试文件：tests/unit/launcher/test_cli.py
import pytest
from unittest.mock import patch, Mock, AsyncMock
from launcher.cli import _create_parser, _handle_up_command

class TestCLIStayMode:
    
    def test_parser_includes_stay_option(self):
        """up子命令解析器应包含--stay选项"""
        parser = _create_parser()
        
        # 测试--stay参数存在
        args = parser.parse_args(["up", "--stay"])
        assert hasattr(args, 'stay')
        assert args.stay is True
        
        # 测试默认行为（不stay）
        args = parser.parse_args(["up"])
        assert args.stay is False
    
    def test_stay_mode_waits_after_apply(self):
        """--stay模式在apply成功后应等待信号"""
        mock_args = Mock()
        mock_args.apply = True
        mock_args.stay = True
        mock_args.json = False
        mock_args.mode = None
        mock_args.components = None
        mock_args.agents = None
        mock_args.reload = False
        
        with patch('launcher.cli.Orchestrator') as mock_orch_class, \
             patch('launcher.cli._asyncio.run') as mock_asyncio_run, \
             patch('builtins.print'):
            
            mock_orch = Mock()
            mock_orch.orchestrate_startup.return_value = True
            mock_orch.get_service_state.return_value.value = 'running'
            mock_orch_class.return_value = mock_orch
            
            _handle_up_command(mock_args)
            
            # 验证_asyncio.run被调用了3次：startup + wait_signal + shutdown
            assert mock_asyncio_run.call_count >= 2
    
    def test_default_mode_exits_immediately(self):
        """默认模式在apply后应立即退出"""
        mock_args = Mock()
        mock_args.apply = True
        mock_args.stay = False
        mock_args.json = False
        mock_args.mode = None
        mock_args.components = None
        mock_args.agents = None
        mock_args.reload = False
        
        with patch('launcher.cli.Orchestrator') as mock_orch_class, \
             patch('launcher.cli._asyncio.run') as mock_asyncio_run, \
             patch('builtins.print'):
            
            mock_orch = Mock()
            mock_orch.orchestrate_startup.return_value = True
            mock_orch.get_service_state.return_value.value = 'running'
            mock_orch_class.return_value = mock_orch
            
            _handle_up_command(mock_args)
            
            # 验证只调用startup，不调用wait信号
            assert mock_asyncio_run.call_count == 1
```

**最小实现（GREEN）**：
```python
# 修改文件：apps/backend/src/launcher/cli.py - 基于现有结构的最小差异修改

# 1. 在_create_parser()函数的up子命令添加--stay参数
# 在现有的up_parser.add_argument列表中添加：
up_parser.add_argument(
    "--stay", 
    action="store_true",
    help="Wait for shutdown signal after starting services (daemon mode)"
)

# 2. 在_handle_up_command函数末尾添加--stay处理逻辑
# 在现有的print(f"Result => ok={ok}, services={status}")后添加：

        # 新增：--stay模式处理
        if getattr(args, 'stay', False):
            from .signal_utils import wait_for_shutdown_signal
            print("🔄 Stay mode enabled, waiting for shutdown signal (Ctrl+C)...")
            
            try:
                # 等待关闭信号
                _asyncio.run(wait_for_shutdown_signal())
                print("📡 Shutdown signal received, stopping services...")
                
                # 优雅关闭服务
                _asyncio.run(orch.orchestrate_shutdown(service_names))
                print("✅ Services stopped gracefully")
                
            except Exception as e:
                print(f"❌ Error during shutdown: {e}")
        else:
            # 默认行为：启动后立即退出（保持现有行为）
            print("💡 Use --stay to wait for shutdown signal.")

# 注意：保持_handle_up_command为同步函数，通过_asyncio.run调用异步函数
```

## 边界条件处理

### 错误场景
1. **进程组强杀失败**
   - 触发条件：进程已退出或权限不足
   - 处理方式：记录错误但继续，不阻塞其他进程停止
   - 测试用例：test_force_terminate_failure_handling

2. **信号注册失败**
   - 触发条件：无运行事件循环或信号被占用
   - 处理方式：返回空清理函数，记录警告
   - 测试用例：test_signal_registration_failure

3. **Windows信号限制**
   - 触发条件：无控制台或服务环境下CTRL_BREAK_EVENT不可靠
   - 处理方式：直接使用process.kill()降级，文档说明限制
   - 测试用例：test_windows_signal_fallback
   - 补充说明：如需级联终止可选taskkill /T /F /PID <pid>（需权限）

4. **agents信号处理冲突**
   - 触发条件：AgentLauncher已用signal.signal绑定SIGINT/SIGTERM
   - 处理方式：CLI只监听SIGINT，避免重复注册
   - 测试用例：test_signal_coexistence_with_agents

5. **主线程信号注册限制**
   - 触发条件：在非主线程调用signal处理器注册
   - 处理方式：确保只在主线程注册，文档标注约束
   - 测试用例：test_signal_registration_thread_safety

### 性能考虑
- 使用asyncio.gather并发处理多个进程的停止
- 避免阻塞等待，使用超时机制
- 最小化信号处理器的执行时间

## 验收标准

### 功能验收
- [ ] 确认现有ProcessManager.terminate_process已满足强制终止需求
- [ ] POSIX系统只监听SIGINT（避免与agents冲突）
- [ ] Windows系统使用signal.signal处理SIGINT
- [ ] CLI up命令新增--stay参数
- [ ] --stay模式在apply成功后等待信号并优雅关闭
- [ ] CLI默认行为完全保持不变（启动后立即退出）
- [ ] 信号回调通过call_soon_threadsafe安全调度

### 技术验收
- [ ] 所有测试通过（模块级覆盖率 > 90%）
- [ ] 使用structlog统一日志格式
- [ ] 测试导入路径符合现有规范
- [ ] Mock目标指向正确模块命名空间

### 集成验收
- [ ] 不修改现有process_utils.py接口
- [ ] 完全保持现有CLI默认行为和输出格式
- [ ] 与现有AgentLauncher.setup_signal_handlers()和谐共存
- [ ] 测试用例基于实际存在的API方法（_create_parser、Orchestrator等）

## 风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| agents信号处理冲突 | 低 | 中 | CLI只监听SIGINT，明确分工 |
| Windows控制台环境限制 | 高 | 低 | kill()降级，详细文档说明 |
| --stay模式理解成本 | 低 | 低 | 清晰帮助文本和使用示例 |
| 测试用例与实际API不匹配 | 低 | 中 | 基于实际代码结构编写测试 |

## 实施检查清单

### 开始前
- [ ] 确认任务5、6已完成并集成测试通过
- [ ] 准备跨平台测试环境(Linux/Windows)
- [ ] 理解信号处理和进程管理原理

### 实施中
- [ ] 每步骤完成后执行跨平台测试
- [ ] 持续集成验证不同操作系统
- [ ] 及时处理平台特定的边界情况

### 完成后
- [ ] 端到端集成测试
- [ ] 性能测试(启动/停止时间)
- [ ] 文档更新(跨平台使用说明)

## 时间估算

| 阶段 | 预计时间 |
|------|----------|
| 技术准备与调研 | 15分钟 |
| 步骤1：确认现有ProcessManager | 10分钟 |
| 步骤2：轻量信号工具 | 45分钟 |
| 步骤3：CLI --stay集成 | 30分钟 |
| 跨平台测试验证 | 20分钟 |
| **总计** | **2小时** |

## 审批状态

- [ ] 计划已审阅
- [ ] 技术方案已确认
- [ ] 准备开始实施

---

## 📋 Technical Review响应

**根据深度技术review意见，本计划已进行全面修订以解决具体实现问题：**

### ⚠️ 关键问题修复

#### 1. **进程管理重复实现问题**
**问题**：计划中新增了不存在的`terminate_process_gracefully`和`shutdown_process`API
**修复**：
- ✅ 复用现有`ProcessManager.terminate_process`（已实现完整的优雅-超时-强杀流程）
- ✅ 只添加薄的`_force_kill_process_group`内部辅助函数
- ✅ 避免接口分裂，减少维护负担

#### 2. **CLI实现脱离现实问题**
**问题**：重写整个CLI为异步，使用不存在的`UnifiedLauncher`和`LaunchConfig`
**修复**：
- ✅ 基于现有`apps/backend/src/launcher/cli.py`结构最小变更
- ✅ 在up子命令添加`--stay`参数（line 43）
- ✅ 在`_handle_up_command`的apply分支添加信号等待逻辑
- ✅ 保持现有输出格式和同步语义

#### 3. **测试用例技术错误问题**
**问题**：测试依赖不存在的API，集成测试逻辑不正确
**修复**：
- ✅ 测试现有的`terminate_process`在超时时使用SIGKILL
- ✅ 修复`test_wait_for_shutdown_signal_integration`回调捕获逻辑
- ✅ 正确处理异步任务取消和finally块执行

#### 4. **信号处理冲突风险**
**问题**：与现有`AgentLauncher.setup_signal_handlers()`可能冲突
**修复**：
- ✅ CLI只监听SIGINT，避免SIGTERM冲突
- ✅ 明确分工：agents处理SIGTERM，CLI处理SIGINT
- ✅ 文档说明主线程注册约束

### 🔧 技术实现细化

#### Windows限制补充
- 无控制台环境下CTRL_BREAK_EVENT不可靠，回退process.kill()
- 文档补充taskkill /T /F选项说明（需权限）

#### 测试策略调整
- 聚焦测试现有API的SIGKILL回退路径
- 修正Mock目标为被测模块命名空间
- 确保异步测试正确处理cleanup

### 📊 修订对比

| 维度 | 原计划 | 修订后 |
|------|--------|--------|
| 进程管理 | 新增_force_kill_process_group | 确认现有terminate_process已足够 |
| CLI实现 | 重写异步main() | 最小化差异修改（只添加--stay） |
| 信号处理 | SIGINT+SIGTERM | 只SIGINT（避免冲突） |
| 测试方法 | 测试虚构API | 测试实际API（_create_parser等） |
| 风险等级 | 中-高（接口分裂） | 低（最小化变更） |

### ✅ 修订验证

**架构一致性**：✅ 完全基于现有代码结构
**接口兼容性**：✅ 零破坏性变更
**测试可执行性**：✅ 所有用例基于实际API
**集成风险**：✅ 与agents信号处理和谐共存

---
*此文档响应了深度技术review的所有关键点，确保实施方案技术可行*