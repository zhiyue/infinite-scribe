# 任务 6 实施计划

生成时间：2025-09-02T13:15:00Z
任务描述：轻量编排器 - 基于显式状态机与拓扑分层，按依赖启动/逆序停止，失败回滚
关联需求：FR-001, FR-002, FR-004, NFR-002
预计工时：4.5小时

## 执行概要

### 目标
实现基于状态机的轻量服务编排器，支持依赖关系管理、有序启停、失败回滚和状态追踪

### 范围
- **包含**：
  - 状态机：
    - 总体（LauncherStatus）：INIT/STARTING/RUNNING/DEGRADED/STOPPING/STOPPED/ERROR
    - 单服务（ServiceStatus）：STOPPED/STARTING/RUNNING/DEGRADED/STOPPING/FAILED（不新增自定义枚举）
  - 依赖图构建和拓扑排序算法
  - 启动失败自动回滚机制
  - 详细状态追踪和错误处理
  - 全面的单元测试覆盖

- **不包含**：
  - 外部基础设施编排（由pnpm infra负责）
  - 复杂的重试机制（留给P2阶段）
  - 指标采集（留给P2阶段）

### 前置条件
- 任务1-5已完成（目录结构、配置模型、CLI、适配器）
- ApiAdapter和AgentsAdapter已实现
- 基础类型和错误定义已就绪

## 技术准备

### 需要的API/库
| 库/模块 | 方法/类 | 用途 | 文档链接 |
|---------|--------|------|---------|
| asyncio | create_task, gather, wait_for, Lock | 并发控制、超时和锁 | [AsyncIO Docs](https://docs.python.org/3/library/asyncio.html) |
| enum | Enum | 状态枚举定义 | [Enum Docs](https://docs.python.org/3/library/enum.html) |
| graphlib | TopologicalSorter, CycleError | 拓扑排序和循环检测 | [GraphLib Docs](https://docs.python.org/3/library/graphlib.html) |
| structlog | get_logger | 结构化日志记录 | [StructLog](https://www.structlog.org/) |
| typing | Dict, List, Optional, Set | 类型注解 | [Typing Docs](https://docs.python.org/3/library/typing.html) |

### 代码位置
- **需要修改的文件**：
  - `apps/backend/src/launcher/orchestrator.py` - 核心编排逻辑（复用现有状态类型）
  - `apps/backend/src/launcher/types.py` - 复用现有 `LauncherStatus`/`ServiceStatus`/`ComponentType`
  - `apps/backend/src/launcher/errors.py` - 复用 `OrchestrationError`/`DependencyNotReadyError` 等已有异常

- **需要创建的文件**：
  - `apps/backend/tests/unit/launcher/test_orchestrator.py` - 编排器单元测试

## TDD实施步骤

### 步骤1：状态机和依赖图基础结构

**测试先行（RED）**：
```python
# 测试文件：tests/unit/launcher/test_orchestrator.py
import pytest
from unittest.mock import Mock, AsyncMock
from src.launcher.orchestrator import Orchestrator
from src.launcher.types import ServiceStatus, ComponentType
from src.launcher.errors import OrchestrationError

class TestOrchestrator:
    @pytest.fixture
    def orchestrator(self):
        mock_config = Mock()
        mock_config.components = [ComponentType.API, ComponentType.AGENTS]
        return Orchestrator(mock_config)
    
    def test_initial_state_tracking(self, orchestrator):
        """所有服务初始状态应为STOPPED（单服务层面）"""
        assert orchestrator.get_service_state("api") == ServiceStatus.STOPPED
        assert orchestrator.get_service_state("agents") == ServiceStatus.STOPPED
    
    def test_dependency_graph_construction(self, orchestrator):
        """依赖图应正确构建API->AGENTS的依赖关系"""
        graph = orchestrator.build_dependency_graph()
        assert "agents" in graph  # agents依赖api
        assert "api" in graph["agents"]
    
    def test_topological_sort_basic(self, orchestrator):
        """拓扑排序应返回正确的启动顺序"""
        levels = orchestrator.get_startup_order(["api", "agents"])  # 返回分层列表
        # api应在更早的层（或同层但不依赖任何服务）
        assert "api" in levels[0]
        assert any("agents" in lvl for lvl in levels[1:])
    
    def test_circular_dependency_detection(self, orchestrator):
        """循环依赖应被检测并抛出异常"""
        # 模拟循环依赖：api -> agents -> api
        orchestrator.build_dependency_graph = Mock(return_value={
            "api": {"agents"},
            "agents": {"api"}
        })
        
        with pytest.raises(OrchestrationError, match="Circular dependency"):
            orchestrator.get_startup_order(["api", "agents"])
```

**最小实现（GREEN）**：
```python
# 实现文件：apps/backend/src/launcher/orchestrator.py
import asyncio
from graphlib import TopologicalSorter, CycleError
from typing import Dict, List, Optional, Set
from .types import ServiceStatus, ComponentType
from .errors import OrchestrationError

class Orchestrator:
    def __init__(self, config):
        self.config = config
        self.services = {}
        self.service_states: Dict[str, ServiceStatus] = {
            c.value: ServiceStatus.STOPPED for c in self.config.components
        }
        self._state_lock = asyncio.Lock()  # 保护状态变更
        self.dependency_graph: Dict[str, Set[str]] = {}  # 缓存依赖图
    
    def get_service_state(self, service_name: str) -> ServiceStatus:
        return self.service_states.get(service_name, ServiceStatus.STOPPED)
    
    async def set_service_state(self, service_name: str, state: ServiceStatus):
        """线程安全的状态设置"""
        async with self._state_lock:
            if self.is_valid_state_transition(
                self.service_states.get(service_name, ServiceStatus.STOPPED),
                state
            ):
                self.service_states[service_name] = state
            else:
                raise OrchestrationError(
                    f"Invalid state transition for {service_name}: "
                    f"{self.service_states[service_name]} -> {state}"
                )
    
    def build_dependency_graph(self) -> Dict[str, Set[str]]:
        """构建服务依赖图（可扩展为从配置读取）"""
        if not self.dependency_graph:
            # TODO: 从配置动态构建
            self.dependency_graph = {
                "agents": {"api"},  # agents依赖api
                "api": set()  # api无依赖
            }
        return self.dependency_graph
    
    def get_startup_order(self, target_services: List[str]) -> List[List[str]]:
        """获取服务启动顺序的分层（每层可并发启动）"""
        deps = self.build_dependency_graph()
        
        # 添加无依赖的服务到图中
        for service in target_services:
            if service not in deps:
                deps[service] = set()
        
        try:
            sorter = TopologicalSorter(deps)
            levels: List[List[str]] = []
            sorter.prepare()
            
            while True:
                ready = list(sorter.get_ready())
                if not ready:
                    break
                # 只包含目标服务
                level = [s for s in ready if s in target_services]
                if level:
                    levels.append(level)
                for r in ready:
                    sorter.done(r)
            
            return levels
            
        except CycleError as e:
            raise OrchestrationError(f"Circular dependency detected: {e}")
```

**重构优化（REFACTOR）**：
- 提取常量定义到types.py
- 添加类型注解完整性
- 优化依赖图构建逻辑
- 实现动态依赖图加载（从配置文件）
- 添加服务注册接口
- 优化日志输出格式

### 步骤2：状态转换和并发启动

**测试先行（RED）**：
```python
@pytest.mark.asyncio
async def test_concurrent_service_startup(self, orchestrator):
    """并发启动服务时状态应正确转换"""
    mock_api = AsyncMock()
    mock_agents = AsyncMock()
    mock_api.start.return_value = True
    mock_agents.start.return_value = True
    
    orchestrator.services = {"api": mock_api, "agents": mock_agents}
    
    result = await orchestrator.orchestrate_startup(["api", "agents"])
    
    assert result is True
    assert orchestrator.get_service_state("api") == ServiceStatus.RUNNING
    assert orchestrator.get_service_state("agents") == ServiceStatus.RUNNING

@pytest.mark.asyncio
async def test_concurrent_level_startup(self, orchestrator):
    """同层服务应并发启动"""
    mock_service1 = AsyncMock()
    mock_service2 = AsyncMock()
    
    # 模拟两个服务都无依赖（同层）
    orchestrator.build_dependency_graph = Mock(return_value={
        "service1": set(),
        "service2": set()
    })
    
    async def delayed_start():
        await asyncio.sleep(0.1)
        return True
    
    mock_service1.start = delayed_start
    mock_service2.start = delayed_start
    
    orchestrator.services = {"service1": mock_service1, "service2": mock_service2}
    
    import time
    start_time = time.time()
    result = await orchestrator.orchestrate_startup(["service1", "service2"])
    elapsed = time.time() - start_time
    
    # 如果是并发，时间应该接近0.1秒而不是0.2秒
    assert elapsed < 0.15
    assert result is True

@pytest.mark.asyncio
async def test_startup_failure_rollback(self, orchestrator):
    """启动失败时应触发回滚"""
    mock_api = AsyncMock()
    mock_agents = AsyncMock()
    mock_api.start.return_value = True
    mock_agents.start.side_effect = Exception("Startup failed")
    
    orchestrator.services = {"api": mock_api, "agents": mock_agents}
    
    result = await orchestrator.orchestrate_startup(["api", "agents"])
    
    assert result is False
    mock_api.stop.assert_called_once()  # 应该回滚已启动的服务
```

**最小实现（GREEN）**：
```python
async def orchestrate_startup(self, target_services: List[str] | None = None) -> bool:
    """按依赖顺序启动服务，同层并发，失败时回滚"""
    services = target_services or [c.value for c in self.config.components]
    startup_levels = self.get_startup_order(services)
    started_services = []
    
    try:
        for level in startup_levels:
            # 同层服务并发启动
            level_tasks = []
            for service_name in level:
                task = self._start_service(service_name)
                level_tasks.append((service_name, task))
            
            # 等待同层所有服务启动完成
            for service_name, task in level_tasks:
                try:
                    # 设置单个服务启动超时（默认30秒）
                    success = await asyncio.wait_for(
                        task, 
                        timeout=getattr(self.config, 'startup_timeout', 30)
                    )
                    if success:
                        started_services.append(service_name)
                    else:
                        raise RuntimeError(f"Failed to start service: {service_name}")
                except asyncio.TimeoutError:
                    raise OrchestrationError(f"Service {service_name} startup timeout")
        
        return True
        
    except Exception as e:
        logger.error("Startup failed, rolling back", error=str(e))
        await self._rollback_startup(started_services)
        return False

async def _start_service(self, service_name: str) -> bool:
    """启动单个服务"""
    try:
        await self.set_service_state(service_name, ServiceStatus.STARTING)
        
        adapter = self.services.get(service_name) or self._create_adapter_by_name(service_name)
        if not adapter:
            raise OrchestrationError(f"Unknown service: {service_name}")
        
        self.services[service_name] = adapter
        
        success = await adapter.start()
        if success:
            await self.set_service_state(service_name, ServiceStatus.RUNNING)
        else:
            await self.set_service_state(service_name, ServiceStatus.FAILED)
            
        return success
        
    except Exception as e:
        logger.error(f"Failed to start {service_name}", error=str(e))
        await self.set_service_state(service_name, ServiceStatus.FAILED)
        raise

async def _rollback_startup(self, started_services: List[str]):
    """回滚已启动的服务（按逆序）"""
    for service_name in reversed(started_services):
        try:
            await self.set_service_state(service_name, ServiceStatus.STOPPING)
            adapter = self.services.get(service_name)
            if adapter:
                # 设置回滚超时（默认10秒）
                await asyncio.wait_for(
                    adapter.stop(),
                    timeout=getattr(self.config, 'stop_grace', 10)
                )
            await self.set_service_state(service_name, ServiceStatus.STOPPED)
        except asyncio.TimeoutError:
            logger.error(f"Rollback timeout for {service_name}")
            await self.set_service_state(service_name, ServiceStatus.FAILED)
        except Exception as e:
            logger.error("Rollback failed", service=service_name, error=str(e))
            await self.set_service_state(service_name, ServiceStatus.FAILED)
```

### 步骤3：优雅停止和状态管理

**测试先行（RED）**：
```python
@pytest.mark.asyncio
async def test_graceful_shutdown_order(self, orchestrator):
    """优雅停止应按逆序进行"""
    mock_api = AsyncMock()
    mock_agents = AsyncMock()
    mock_api.stop.return_value = True
    mock_agents.stop.return_value = True
    
    orchestrator.services = {"api": mock_api, "agents": mock_agents}
    orchestrator.service_states = {"api": ServiceStatus.RUNNING, "agents": ServiceStatus.RUNNING}
    
    result = await orchestrator.orchestrate_shutdown()
    
    assert result is True
    # agents应该先停止，然后是api
    assert mock_agents.stop.call_count == 1
    assert mock_api.stop.call_count == 1

def test_state_transitions_valid(self, orchestrator):
    """状态转换应符合状态机规则"""
    assert orchestrator.is_valid_state_transition(ServiceStatus.STOPPED, ServiceStatus.STARTING)
    assert orchestrator.is_valid_state_transition(ServiceStatus.STARTING, ServiceStatus.RUNNING)
    assert orchestrator.is_valid_state_transition(ServiceStatus.RUNNING, ServiceStatus.STOPPING)
    assert not orchestrator.is_valid_state_transition(ServiceStatus.STOPPED, ServiceStatus.RUNNING)
```

**最小实现（GREEN）**：
```python
async def orchestrate_shutdown(self, target_services: List[str] | None = None) -> bool:
    """按逆序优雅停止服务（逐层逆序）"""
    services = target_services or list(self.services.keys())
    startup_levels = self.get_startup_order(services)
    
    # 逐层逆序停止（后启动的先停止）
    success_count = 0
    for level in reversed(startup_levels):
        # 同层可以并发停止
        stop_tasks = []
        for service_name in level:
            if service_name in self.services:
                task = self._stop_service(service_name)
                stop_tasks.append((service_name, task))
        
        # 等待同层所有服务停止
        for service_name, task in stop_tasks:
            try:
                success = await asyncio.wait_for(
                    task,
                    timeout=getattr(self.config, 'stop_grace', 10)
                )
                if success:
                    success_count += 1
            except asyncio.TimeoutError:
                logger.error(f"Shutdown timeout for {service_name}")
                await self.set_service_state(service_name, ServiceStatus.FAILED)
            except Exception as e:
                logger.error(f"Shutdown failed for {service_name}", error=str(e))
    
    return success_count == len(services)

async def _stop_service(self, service_name: str) -> bool:
    """停止单个服务"""
    try:
        await self.set_service_state(service_name, ServiceStatus.STOPPING)
        adapter = self.services.get(service_name)
        
        if adapter:
            success = await adapter.stop()
            if success:
                await self.set_service_state(service_name, ServiceStatus.STOPPED)
            else:
                await self.set_service_state(service_name, ServiceStatus.FAILED)
            return success
        
        return False
        
    except Exception as e:
        logger.error(f"Failed to stop {service_name}", error=str(e))
        await self.set_service_state(service_name, ServiceStatus.FAILED)
        return False

def is_valid_state_transition(self, from_state: ServiceStatus, to_state: ServiceStatus) -> bool:
    """验证状态转换是否合法"""
    valid_transitions = {
        ServiceStatus.STOPPED: {ServiceStatus.STARTING},
        ServiceStatus.STARTING: {ServiceStatus.RUNNING, ServiceStatus.FAILED},
        ServiceStatus.RUNNING: {ServiceStatus.STOPPING, ServiceStatus.DEGRADED, ServiceStatus.FAILED},
        ServiceStatus.DEGRADED: {ServiceStatus.STOPPING, ServiceStatus.RUNNING, ServiceStatus.FAILED},
        ServiceStatus.STOPPING: {ServiceStatus.STOPPED, ServiceStatus.FAILED},
        ServiceStatus.FAILED: {ServiceStatus.STARTING, ServiceStatus.STOPPING}
    }
    return to_state in valid_transitions.get(from_state, set())
```

### 步骤4：错误处理和诊断

**测试先行（RED）**：
```python
@pytest.mark.asyncio
async def test_service_health_monitoring(self, orchestrator):
    """服务健康检查应正确更新状态"""
    mock_adapter = AsyncMock()
    mock_adapter.health_check.return_value = {"status": "unhealthy"}
    orchestrator.services["api"] = mock_adapter
    orchestrator.service_states["api"] = ServiceStatus.RUNNING
    
    await orchestrator.update_service_health("api")
    
    assert orchestrator.get_service_state("api") == ServiceStatus.DEGRADED

def test_error_context_collection(self, orchestrator):
    """错误时应收集详细的上下文信息"""
    error_context = orchestrator.collect_error_context("api")
    
    assert "service_name" in error_context
    assert "current_state" in error_context
    assert "dependencies" in error_context
    assert "error_timestamp" in error_context

@pytest.mark.asyncio
async def test_startup_timeout_handling(self, orchestrator):
    """启动超时应正确处理"""
    mock_api = AsyncMock()
    
    async def slow_start():
        await asyncio.sleep(2)  # 模拟缓慢启动
        return True
    
    mock_api.start = slow_start
    orchestrator.services = {"api": mock_api}
    orchestrator.config.startup_timeout = 1  # 1秒超时
    
    result = await orchestrator.orchestrate_startup(["api"])
    
    assert result is False
    assert orchestrator.get_service_state("api") == ServiceStatus.FAILED

@pytest.mark.asyncio
async def test_concurrent_state_mutations(self, orchestrator):
    """并发状态修改应该安全"""
    async def change_state(state):
        await orchestrator.set_service_state("api", state)
    
    # 尝试并发修改状态
    tasks = [
        change_state(ServiceStatus.STARTING),
        change_state(ServiceStatus.RUNNING),
        change_state(ServiceStatus.STOPPING)
    ]
    
    with pytest.raises(OrchestrationError):  # 应该因为无效转换抛出异常
        await asyncio.gather(*tasks, return_exceptions=False)
```

**最小实现（GREEN）**：
```python
async def update_service_health(self, service_name: str):
    """更新服务健康状态"""
    adapter = self.services.get(service_name)
    if not adapter:
        return
        
    try:
        health = await adapter.health_check()
        is_healthy = (isinstance(health, dict) and health.get("status") in {"healthy", "running"}) or bool(health)
        current_state = self.service_states[service_name]
        
        if current_state == ServiceStatus.RUNNING and not is_healthy:
            self.service_states[service_name] = ServiceStatus.DEGRADED
        elif current_state == ServiceStatus.DEGRADED and is_healthy:
            self.service_states[service_name] = ServiceStatus.RUNNING
            
    except Exception as e:
        logger.error("Health check failed", service=service_name, error=str(e))
        self.service_states[service_name] = ServiceStatus.FAILED

def collect_error_context(self, service_name: str) -> dict:
    """收集错误诊断信息"""
    from datetime import datetime, UTC
    
    return {
        "service_name": service_name,
        "current_state": self.service_states.get(service_name, ServiceStatus.STOPPED).value,
        "dependencies": list(self.build_dependency_graph().get(service_name, set())),
        "error_timestamp": datetime.now(UTC).isoformat(),
        "config": {
            "mode": getattr(self.config.default_mode, "value", self.config.default_mode),
            "components": [c.value for c in self.config.components]
        }
    }
```

## 边界情况处理

### 错误场景
1. **循环依赖检测**
   - 触发条件：依赖图中存在循环
   - 处理方式：在build_dependency_graph/get_startup_order时检测并抛出 OrchestrationError
   - 测试用例：test_circular_dependency_detection

2. **适配器创建失败**
   - 触发条件：未知服务名或适配器初始化错误
   - 处理方式：记录详细错误并停止启动流程，抛出 OrchestrationError
   - 测试用例：test_unknown_service_error

3. **部分启动失败**
   - 触发条件：某个服务启动失败但其他已启动
   - 处理方式：回滚所有已启动的服务
   - 测试用例：test_partial_startup_failure_rollback

4. **启动超时**
   - 触发条件：服务启动时间超过配置的超时时间
   - 处理方式：标记服务为FAILED，回滚已启动服务
   - 测试用例：test_startup_timeout_handling

5. **回滚失败**
   - 触发条件：回滚过程中stop操作失败或超时
   - 处理方式：记录错误，继续回滚其他服务，标记失败服务为FAILED
   - 测试用例：test_rollback_failure_handling

6. **并发状态竞争**
   - 触发条件：多个协程同时尝试修改同一服务状态
   - 处理方式：使用asyncio.Lock保护状态变更
   - 测试用例：test_concurrent_state_mutations

### 性能考虑
- 使用asyncio.gather进行并发操作（同层服务并发启动/停止）
- 状态转换时间复杂度O(1)，带锁保护避免竞争
- 拓扑排序时间复杂度O(V+E)
- 启动超时控制避免无限等待
- 内存占用优化：依赖图缓存，避免重复计算

## 验收标准

### 功能验收
- [ ] 服务按依赖顺序正确启动（api -> agents）
- [ ] 同层服务并发启动（性能提升）
- [ ] 服务按逆序正确停止（agents -> api）
- [ ] 同层服务并发停止（性能提升）
- [ ] 启动失败时自动回滚已启动服务
- [ ] 支持服务状态（STOPPED/STARTING/RUNNING/DEGRADED/STOPPING/FAILED）
- [ ] 状态转换验证和锁保护
- [ ] 提供详细的错误上下文信息
- [ ] 循环依赖检测和报告
- [ ] 启动/停止超时控制

### 技术验收
- [ ] 所有测试通过（单元测试覆盖率 > 90%）
- [ ] 代码复杂度符合标准（圈复杂度 < 10）
- [ ] 无 linting 错误（ruff check）
- [ ] 类型注解完整性检查通过（mypy）
- [ ] 异步代码正确性（无死锁、无泄漏）
- [ ] 日志输出完整且结构化
- [ ] 错误消息清晰有帮助

### 集成验收
- [ ] 与CLI命令正确集成（up/down/status）
- [ ] 与适配器层正确协作
- [ ] 为后续健康监控任务提供状态接口

## 风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 依赖图复杂度过高 | 低 | 中 | 使用标准graphlib库，限制依赖深度 |
| 并发状态竞争 | 中 | 高 | 使用asyncio锁保护状态变更 |
| 回滚操作失败 | 中 | 高 | 多重异常捕获，记录详细日志 |
| 性能影响过大 | 低 | 中 | 基准测试验证，优化热点路径 |

## 实施检查清单

### 开始前
- [ ] 确认任务1-5完成状态
- [ ] 验证适配器接口是否stable
- [ ] 理解服务依赖关系

### 实施中
- [ ] 遵循TDD红-绿-重构流程
- [ ] 每步骤后运行测试套件
- [ ] 及时提交增量变更

### 完成后
- [ ] 运行完整测试套件（超时60秒）
- [ ] 代码质量检查（ruff, mypy）
- [ ] 集成测试验证
- [ ] 更新任务状态为完成

## 时间估算

| 阶段 | 预计时间 | 调整后 | 说明 |
|------|----------|--------|------|
| 技术准备与设计 | 30分钟 | 30分钟 | - |
| 步骤1：状态机基础 | 90分钟 | 90分钟 | 包含循环依赖检测 |
| 步骤2：并发启动 | 100分钟 | 120分钟 | 增加并发逻辑和超时控制 |
| 步骤3：优雅停止 | 70分钟 | 80分钟 | 增加分层逆序停止 |
| 步骤4：错误处理 | 60分钟 | 70分钟 | 增加锁机制和诊断 |
| 测试完善与验证 | 30分钟 | 40分钟 | 更多边界测试 |
| **总计** | **4.5小时** | **5.5小时** | 考虑额外复杂度 |

## 审批状态

- [x] 计划已审阅（2025-09-02）
- [x] 技术方案已确认（增强并发和错误处理）
- [x] 准备开始实施

## 实施注意事项

1. **优先级**：
   - P0: 基础状态机和依赖管理
   - P1: 并发启动和停止
   - P2: 超时控制和锁保护
   - P3: 动态依赖图和高级诊断

2. **关键技术点**：
   - 使用`graphlib.TopologicalSorter`进行依赖排序
   - 使用`asyncio.Lock`保护状态变更
   - 使用`asyncio.wait_for`实现超时控制
   - 分层并发提高启动/停止性能

3. **测试策略**：
   - 先写测试，后写实现（TDD）
   - 每个步骤完成后运行测试
   - 注重边界情况和错误场景
   - 使用Mock隔离外部依赖

---
*此文档由 spec-task:impl-task-plan 生成，作为任务6实施的详细指导*
