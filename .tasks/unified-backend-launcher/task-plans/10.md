# 任务 10 实施计划

生成时间：2025-09-02
任务描述：结构化日志 - 统一使用 `structlog`，字段：component、mode、state、elapsed_ms、attempt、error_type
关联需求：NFR-005
预计工时：4 小时

## 执行概要

### 目标
实现全后端通用的结构化日志基础设施，为API Gateway、Agents、Launcher等所有后端服务提供统一的日志配置和接口，确保日志格式标准化、可观测且便于调试。

### 范围
- **包含**：
  - 创建 `src/core/logging/` 全后端通用日志模块
  - 实现统一的日志配置和获取接口
  - 支持上下文绑定（request_id、trace_id、user_id等）
  - 标准化日志字段：component、mode、state、elapsed_ms、attempt、error_type
  - stdlib到structlog的桥接，避免双轨日志
  - 幂等配置机制和环境适配
  - 渐进式迁移现有日志调用

- **不包含**：
  - 一次性替换所有现有日志调用（采用渐进迁移）
  - 修改外部依赖库的日志行为
  - 添加日志聚合或外部日志传输系统

### 前置条件
- 任务 1-9 已完成（启动器基础架构就位）
- structlog 依赖已添加到 pyproject.toml
- 启动器组件已实现基本功能

## 技术准备

### 需要的API/库
| 库/模块 | 方法/类 | 用途 | 文档链接 |
|---------|--------|------|---------|
| structlog | configure, get_logger | 结构化日志配置和获取 | https://structlog.org |
| structlog.processors | JSONRenderer, TimeStamper | JSON格式化和时间戳 | https://structlog.org/processors |
| structlog.contextvars | bind_contextvars | 上下文变量绑定 | https://structlog.org/contextvars |
| enum | Enum | 日志级别和错误类型定义 | Python标准库 |
| typing | Dict, Optional, Any | 类型提示 | Python标准库 |

### 代码位置
- **需要创建的文件**：
  - `apps/backend/src/core/logging/__init__.py` - 统一导出入口
  - `apps/backend/src/core/logging/config.py` - 日志配置模块（configure_logging, get_logger）
  - `apps/backend/src/core/logging/context.py` - 上下文绑定（request_id, trace_id, user_id）
  - `apps/backend/src/core/logging/processors.py` - 自定义处理器（序列化兜底、字段规范）
  - `apps/backend/src/core/logging/types.py` - 日志相关类型定义
  
- **需要修改的文件**：
  - `apps/backend/src/launcher/types.py` - 扩展ComponentType枚举添加HEALTH、ORCHESTRATOR、CLI
    ```python
    class ComponentType(Enum):
        API = "api"
        AGENTS = "agents"
        # 新增扩展类型
        HEALTH = "health"
        ORCHESTRATOR = "orchestrator" 
        CLI = "cli"
    ```
  - `apps/backend/src/launcher/cli.py` - 使用新的logging模块初始化
  - `apps/backend/src/launcher/health.py` - 迁移到统一日志接口
  - `apps/backend/src/launcher/orchestrator.py` - 迁移到统一日志接口
  - `apps/backend/src/launcher/adapters/*.py` - 迁移到统一日志接口
  - `apps/backend/src/api/main.py` - 在应用启动时配置日志
  - `apps/backend/src/agents/launcher.py` - 移除logging.basicConfig，使用统一配置

## TDD实施步骤

### 步骤1：核心日志配置模块
**测试先行（RED）**：
```python
# 测试文件：tests/unit/core/logging/test_config.py
import pytest
import structlog
import logging
from src.core.logging.config import configure_logging, get_logger

def test_configure_logging_development():
    """测试开发环境日志配置"""
    # 准备
    config = configure_logging(
        environment="development",
        level="DEBUG",
        output_format="console",
        enable_stdlib_bridge=True
    )
    
    # 执行 & 断言
    assert config["configured"] is True
    logger = get_logger("test_component")
    assert hasattr(logger, 'info')
    assert hasattr(logger, 'bind')

def test_configure_logging_production():
    """测试生产环境日志配置（JSON格式）"""
    # 准备
    config = configure_logging(
        environment="production", 
        level="INFO",
        output_format="json",
        enable_stdlib_bridge=True
    )
    
    # 执行
    logger = get_logger("api_adapter")
    
    # 断言
    assert config["configured"] is True
    assert config["format"] == "json"
    assert logger is not None
    # 测试绑定上下文
    bound_logger = logger.bind(
        component="api",
        service="api-gateway",
        state="starting"
    )
    assert bound_logger is not None

def test_stdlib_bridge():
    """测试stdlib到structlog的桥接"""
    import logging
    
    # 准备
    configure_logging(environment="development", enable_stdlib_bridge=True)
    
    # 使用标准库logger
    stdlib_logger = logging.getLogger("test.stdlib")
    
    # 执行 & 断言（应该不会报错，日志被structlog处理）
    stdlib_logger.info("This should be handled by structlog")
    
def test_idempotent_configuration():
    """测试幂等配置"""
    # 准备 & 执行
    config1 = configure_logging(environment="development")
    config2 = configure_logging(environment="development")  # 重复配置
    
    # 断言
    assert config1["configured"] is True
    assert config2["already_configured"] is True  # 幂等标识

def test_force_reconfigure():
    """测试强制重配置（推荐用于单测中的初始化）"""
    # 准备：先配置一次
    configure_logging(environment="development")
    
    # 执行：强制重配置（单测推荐用法）
    config = configure_logging(
        environment="production",
        force_reconfigure=True  # 避免pytest多入口初始化顺序问题
    )
    
    # 断言
    assert config["configured"] is True
    assert "already_configured" not in config
```

**测试提示**：
- **单测建议使用`force_reconfigure=True`**：避免pytest/多入口初始化顺序带来的偶发不一致
- **CI/CD环境特别重要**：多个测试文件可能随机顺序执行，导致配置冲突
- **生产代码谨慎使用**：仅在确实需要重配置时使用

```

**最小实现（GREEN）**：
```python
# 实现文件：src/core/logging/config.py
import structlog
import logging
from typing import Optional, Dict, Any

# 全局配置状态
_CONFIGURED = False

def configure_logging(
    environment: str = "development",
    level: str = "INFO", 
    output_format: str = "auto",  # auto, json, console
    enable_stdlib_bridge: bool = True,
    force_reconfigure: bool = False,
    access_logs: bool = None  # None=auto based on environment
) -> Dict[str, Any]:
    """配置全后端通用结构化日志"""
    global _CONFIGURED
    
    if _CONFIGURED and not force_reconfigure:
        return {"already_configured": True}
    
    # 确定输出格式
    if output_format == "auto":
        json_format = environment == "production"
    else:
        json_format = output_format == "json"
    
    # 构建共享的处理器链（用于structlog和stdlib）
    shared_processors = [
        structlog.contextvars.merge_contextvars,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
    ]
    
    # 选择最终渲染器
    if json_format:
        renderer = structlog.processors.JSONRenderer(default=str)
    else:
        renderer = structlog.dev.ConsoleRenderer()
    
    # 配置structlog
    structlog.configure(
        processors=shared_processors + [
            structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
        ],
        wrapper_class=structlog.stdlib.BoundLogger,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )
    
    # 桥接stdlib到structlog（使用ProcessorFormatter）
    if enable_stdlib_bridge:
        formatter = structlog.stdlib.ProcessorFormatter(
            processor=renderer,
            foreign_pre_chain=shared_processors,
        )
        
        handler = logging.StreamHandler()
        handler.setFormatter(formatter)
        
        # 配置root logger
        root = logging.getLogger()
        root.handlers.clear()  # 清除默认handlers
        root.addHandler(handler)
        root.setLevel(getattr(logging, level.upper()))
        
        # 配置uvicorn日志统一到structlog
        uvicorn_logger = logging.getLogger("uvicorn")
        uvicorn_logger.handlers.clear()
        uvicorn_logger.propagate = True
        uvicorn_logger.setLevel(logging.INFO)
        
        # access日志根据环境配置
        access_level = logging.INFO if (access_logs if access_logs is not None 
                                      else environment == "development") else logging.WARNING
        uvicorn_access = logging.getLogger("uvicorn.access") 
        uvicorn_access.handlers.clear()
        uvicorn_access.propagate = True
        uvicorn_access.setLevel(access_level)
        
        # error日志统一到structlog（某些uvicorn版本有独立handler）
        uvicorn_error = logging.getLogger("uvicorn.error")
        uvicorn_error.handlers.clear()
        uvicorn_error.propagate = True
        uvicorn_error.setLevel(logging.ERROR)
    
    _CONFIGURED = True
    return {
        "configured": True, 
        "format": "json" if json_format else "console",
        "processors": len(shared_processors) + 1,
        "stdlib_bridge": enable_stdlib_bridge
    }

def get_logger(name: str) -> structlog.BoundLogger:
    """获取通用结构化日志器"""
    return structlog.get_logger(name)
```

**重构优化（REFACTOR）**：
- 添加环境变量优先级处理
- 增加配置验证和错误处理
- 优化性能和内存使用

### 步骤2：上下文绑定功能
**测试先行（RED）**：
```python
# 测试文件：tests/unit/core/logging/test_context.py
import pytest
from src.core.logging.context import (
    bind_request_context, bind_service_context, 
    get_current_context, clear_context
)
from src.core.logging.config import get_logger

def test_bind_request_context():
    """测试绑定请求上下文"""
    # 准备
    request_id = "req_123456"
    user_id = "user_789"
    
    # 执行
    bind_request_context(request_id=request_id, user_id=user_id)
    logger = get_logger("test")
    
    # 断言 - 日志应该自动包含上下文字段
    # 这里通过检查是否能正常绑定来验证
    bound_logger = logger.bind(test_field="test_value")
    assert bound_logger is not None

def test_bind_service_context():
    """测试绑定服务上下文"""
    # 准备
    service = "api-gateway"
    component = "auth"
    
    # 执行
    bind_service_context(service=service, component=component)
    current_context = get_current_context()
    
    # 断言
    assert current_context.get("service") == service
    assert current_context.get("component") == component

def test_clear_context():
    """测试清除上下文"""
    # 准备
    bind_request_context(request_id="test_123")
    assert get_current_context().get("request_id") == "test_123"
    
    # 执行
    clear_context()
    
    # 断言
    assert get_current_context().get("request_id") is None
```

**最小实现（GREEN）**：
```python
# 实现文件：src/core/logging/context.py
import contextvars
from typing import Dict, Any, Optional
import structlog

# 上下文变量存储
_context: contextvars.ContextVar[Dict[str, Any]] = contextvars.ContextVar(
    'logging_context', default={}
)

def bind_request_context(
    request_id: str, 
    user_id: Optional[str] = None,
    trace_id: Optional[str] = None,
    **kwargs
) -> None:
    """绑定请求上下文到当前执行上下文"""
    context = _context.get().copy()
    
    context.update({
        "request_id": request_id,
        "user_id": user_id,
        "trace_id": trace_id or request_id,
        **kwargs
    })
    
    _context.set(context)
    
    # 使用structlog的contextvars绑定
    structlog.contextvars.bind_contextvars(**{
        k: v for k, v in context.items() if v is not None
    })

def bind_service_context(
    service: str,
    component: str,
    version: Optional[str] = None,
    **kwargs
) -> None:
    """绑定服务上下文"""
    context = _context.get().copy()
    
    context.update({
        "service": service,
        "component": component,
        "version": version,
        **kwargs
    })
    
    _context.set(context)
    structlog.contextvars.bind_contextvars(**{
        k: v for k, v in context.items() if v is not None
    })

def get_current_context() -> Dict[str, Any]:
    """获取当前上下文"""
    return _context.get().copy()

def clear_context() -> None:
    """清除当前上下文"""
    _context.set({})
    structlog.contextvars.clear_contextvars()
```

### 步骤3：自定义处理器和类型定义
**测试先行（RED）**：
```python
# 测试文件：tests/unit/core/logging/test_processors.py
import pytest
from src.core.logging.processors import (
    SerializationFallbackProcessor, 
    StandardFieldsProcessor
)
from src.core.logging.types import ErrorType

def test_serialization_fallback_processor():
    """测试序列化兜底处理器"""
    processor = SerializationFallbackProcessor()
    
    # 准备包含不可序列化对象的日志事件
    class NonSerializable:
        def __repr__(self):
            return "NonSerializable()"
    
    event_dict = {
        "message": "Test",
        "obj": NonSerializable(),
        "normal_field": "normal_value"
    }
    
    # 执行
    result = processor(None, None, event_dict)
    
    # 断言
    assert result["obj"] == "NonSerializable()"
    assert result["normal_field"] == "normal_value"
    assert result.get("serialization_fallback") is True

def test_standard_fields_processor():
    """测试标准字段处理器"""
    processor = StandardFieldsProcessor()
    
    event_dict = {
        "message": "Test message",
        "component": "api",
        "state": "starting"
    }
    
    # 执行
    result = processor(None, None, event_dict)
    
    # 断言
    assert "timestamp" in result
    assert result["component"] == "api"
    assert result["state"] == "starting"

def test_error_type_enum():
    """测试错误类型枚举"""
    assert ErrorType.TIMEOUT.value == "timeout"
    assert ErrorType.CONNECTION_ERROR.value == "connection_error"
    assert ErrorType.CONFIG_ERROR.value == "config_error"
```

**最小实现（GREEN）**：
```python
# 实现文件：src/core/logging/processors.py
from typing import Any, Dict
import time

class SerializationFallbackProcessor:
    """序列化兜底处理器"""
    
    def __call__(self, logger, name, event_dict: Dict[str, Any]) -> Dict[str, Any]:
        """处理不可序列化的对象"""
        has_fallback = False
        
        for key, value in event_dict.items():
            if not self._is_serializable(value):
                event_dict[key] = str(value)
                has_fallback = True
        
        if has_fallback:
            event_dict["serialization_fallback"] = True
            
        return event_dict
    
    def _is_serializable(self, obj: Any) -> bool:
        """检查对象是否可序列化"""
        try:
            import json
            json.dumps(obj, default=str)
            return True
        except (TypeError, ValueError):
            return False

class StandardFieldsProcessor:
    """
    标准字段处理器（默认不启用，避免与TimeStamper重复）
    
    注意：当前未在默认处理器链中使用，因为：
    1. 时间戳由TimeStamper统一处理
    2. 避免处理器链重复添加字段
    3. 可按需在特定场景下启用
    """
    
    def __call__(self, logger, name, event_dict: Dict[str, Any]) -> Dict[str, Any]:
        """添加标准字段（除时间戳外）"""
        # 示例：可添加全局标准字段
        # event_dict.setdefault('service_version', '1.0.0')
        # event_dict.setdefault('deployment', 'production')
        return event_dict


# 实现文件：src/core/logging/types.py  
from enum import Enum

class ErrorType(Enum):
    """错误类型枚举"""
    TIMEOUT = "timeout"
    CONNECTION_ERROR = "connection_error"
    CONFIG_ERROR = "config_error"
    DEPENDENCY_ERROR = "dependency_error"
    VALIDATION_ERROR = "validation_error"
    STARTUP_ERROR = "startup_error"
    SHUTDOWN_ERROR = "shutdown_error"

# ComponentType由launcher/types.py维护，这里不重复定义
```

### 步骤4：统一接口模块
**实现（GREEN）**：
```python
# 实现文件：src/core/logging/__init__.py
"""
统一后端日志模块

提供全后端通用的结构化日志配置和接口
"""

from .config import configure_logging, get_logger
from .context import (
    bind_request_context, 
    bind_service_context,
    get_current_context,
    clear_context
)
from .types import ErrorType
# 导入ComponentType（扩展版本）
from src.launcher.types import ComponentType

# 导出统一接口
__all__ = [
    # 核心接口
    "configure_logging",
    "get_logger",
    
    # 上下文绑定
    "bind_request_context",
    "bind_service_context", 
    "get_current_context",
    "clear_context",
    
    # 类型定义
    "ErrorType",
    "ComponentType",
]

# 版本信息
__version__ = "1.0.0"
```

### 步骤5：CLI和Launcher集成
**关键改动**：
```python
# 修改文件：src/launcher/cli.py
import os
from src.core.logging import configure_logging, get_logger, bind_service_context

def main():
    """主入口函数"""
    # 配置全后端日志（在最前面）
    environment = os.getenv('INFINITE_SCRIBE_ENV', 'development') 
    configure_logging(
        environment=environment,
        level='INFO',
        output_format='auto',  # 开发用console，生产用json
        enable_stdlib_bridge=True
    )
    
    # 绑定服务上下文
    bind_service_context(service="launcher", component="cli")
    logger = get_logger(__name__)
    
    # 继续原有逻辑...
    parser = _create_parser()
    args = parser.parse_args()
    
    logger.info("启动器CLI初始化完成", command=args.command)
    # ... 其余逻辑保持不变
```

### 步骤6：API Gateway集成
**关键改动**：
```python
# 修改文件：src/api/main.py
import uuid
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request
from src.core.logging import configure_logging, get_logger, bind_request_context, clear_context

# 在应用启动时配置日志
@asynccontextmanager
async def lifespan(app: FastAPI):
    # 配置日志（如果还未配置）
    configure_logging(
        environment=settings.environment,
        level=getattr(settings, 'log_level', 'INFO'),
        output_format='auto',
        enable_stdlib_bridge=True
    )
    
    logger = get_logger(__name__)
    logger.info("API Gateway启动", 
                environment=settings.environment,
                service="api-gateway")
    
    # ... 原有启动逻辑
    yield
    # ... 原有清理逻辑

# 请求中间件绑定上下文
@app.middleware("http")
async def logging_middleware(request: Request, call_next):
    request_id = str(uuid.uuid4())
    
    try:
        # 绑定请求上下文
        bind_request_context(
            request_id=request_id,
            user_id=getattr(request.state, 'user_id', None),
            trace_id=request.headers.get('X-Trace-ID', request_id)
        )
        
        response = await call_next(request)
        response.headers["X-Request-ID"] = request_id
        return response
        
    finally:
        # 清理上下文避免污染
        clear_context()
```

### 步骤7：Agents集成  
**关键改动**：
```python
# 修改文件：src/agents/launcher.py
# 移除原有的 logging.basicConfig
# 替换为：
from src.core.logging import configure_logging, get_logger, bind_service_context

# 在agents启动时配置（如果还未配置）
configure_logging()
bind_service_context(service="agents", component="launcher")
logger = get_logger(__name__)  # 替换原有的 logging.getLogger
```

### 字段绑定最佳实践

**分层绑定策略**（推荐模式）：

```python
# 模块级绑定：组件类型（在模块顶部或类初始化）
logger = get_logger(__name__).bind(component=ComponentType.AGENTS.value)

# 服务级绑定：服务上下文（在服务启动时）
logger = logger.bind(service="agents", version="1.0.0")

# 操作级绑定：状态和度量（在具体操作中）
def start_agent():
    operation_logger = logger.bind(
        state="starting",
        operation="agent_startup"
    )
    
    start_time = time.time()
    try:
        operation_logger.info("开始启动Agent")
        # ... 启动逻辑
        operation_logger.info("Agent启动成功", 
                            state="running",
                            elapsed_ms=int((time.time() - start_time) * 1000))
    except Exception as e:
        operation_logger.error("Agent启动失败",
                             state="failed", 
                             error_type=ErrorType.STARTUP_ERROR.value,
                             elapsed_ms=int((time.time() - start_time) * 1000))
        raise
```

**绑定层级说明**：
1. **模块级**：`component=ComponentType.XXX` - 标识代码所属组件
2. **服务级**：`service="agents", version="1.0.0"` - 标识服务实例
3. **操作级**：`state="starting", elapsed_ms=...` - 标识具体操作状态

**一致性优势**：
- 避免重复绑定相同字段
- 确保每个日志都包含完整的上下文层次
- 便于日志聚合和分析
- 提升代码可读性和维护性

```

## 渐进式迁移策略

### 阶段1：核心基础设施（1小时）
- 实现 `src/core/logging/` 模块
- CLI和launcher组件迁移
- 基础测试通过

### 阶段2：API集成（1小时） 
- API Gateway集成日志配置
- 请求上下文绑定中间件
- Web场景测试

### 阶段3：Agents集成（1小时）
- Agents模块迁移
- 服务上下文绑定
- 端到端测试

### 阶段4：优化完善（1小时）
- 性能优化和监控
- 文档完善
- 代码审查

## 边界情况处理

### 错误场景
1. **重复配置**：幂等机制确保不会重复配置
2. **序列化失败**：自定义处理器提供fallback
3. **上下文丢失**：contextvars自动传播上下文

### 验收标准

### 功能验收
- [ ] 全后端统一日志配置和接口
- [ ] 请求级上下文自动绑定（request_id、user_id）
- [ ] 服务级上下文绑定（service、component）
- [ ] 标准字段支持：component、mode、state、elapsed_ms、attempt、error_type
- [ ] 环境适配：开发console格式，生产json格式
- [ ] stdlib到structlog桥接正常

### 技术验收
- [ ] 所有测试通过
- [ ] 代码覆盖率 > 85%
- [ ] 性能开销 < 3%
- [ ] 幂等配置和错误处理完善

## 时间估算

| 阶段 | 预计时间 |
|------|----------|
| 核心模块实现 | 1小时 |
| CLI和Launcher集成 | 1小时 |
| API Gateway集成 | 1小时 |
| Agents集成和测试 | 1小时 |
| **总计** | 4小时 |

## 性能优化建议

### 等级过滤优化
**默认关闭，按需开启**。为提升日志处理性能，可在structlog处理器链最前端添加等级过滤：

```python
# 在configure_logging函数的shared_processors中添加（性能优化选项）
shared_processors = [
    # 【可选】等级过滤优化 - 放在最前端以最大化性能收益
    # structlog.stdlib.filter_by_level,  # 默认关闭，按需开启
    
    # 原有处理器链
    structlog.contextvars.merge_contextvars,
    structlog.stdlib.add_logger_name,
    # ... 其他处理器
]

# 如需启用，可在高并发/大日志量场景下取消注释
# 或通过配置参数动态控制：
# if enable_level_filter:  # 可通过环境变量控制
#     shared_processors.insert(0, structlog.stdlib.filter_by_level)
```

**策略说明**：
- **默认关闭**：避免默认配置过于复杂，确保稳定性
- **按需开启**：在确认有性能需求时启用
- **位置关键**：必须放在shared_processors最前端，确保最大性能收益

**适用场景**：
- 高并发生产环境（QPS > 1000）
- DEBUG日志量很大的开发环境
- 对日志处理性能有严格要求的场景

### 入口时机最佳实践
确保在各服务最早时刻调用`configure_logging`：

```python
# 推荐：在模块导入时或main函数最开始配置
if __name__ == "__main__":
    configure_logging(...)  # 第一行
    # ... 其他初始化逻辑
```

**重要性**：
- 避免早期日志使用默认格式输出
- 确保所有日志都使用统一格式
- 特别重要在CLI工具和服务启动脚本中

## 风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| ProcessorFormatter配置复杂 | 中 | 中 | 使用structlog官方推荐方案，完整测试覆盖 |
| 上下文传播失效 | 低 | 中 | contextvars自动传播，异步兼容测试 |
| ComponentType导入混乱 | 低 | 中 | 单一来源维护，统一重导出接口 |
| uvicorn日志桥接问题 | 中 | 中 | ProcessorFormatter统一渲染，handlers.clear()避免重复 |

## 实施重点提醒

### ProcessorFormatter关键点
- **共享处理器链**：stdlib和structlog使用相同的处理器，确保格式统一
- **避免重复输出**：清除uvicorn原有handlers，使用propagate=True
- **上下文保持**：foreign_pre_chain确保stdlib日志也包含上下文字段

### ComponentType统一管理
- **单一来源**：仅在`launcher/types.py`维护ComponentType定义
- **扩展添加**：新增HEALTH、ORCHESTRATOR、CLI三个类型
- **统一导出**：通过`core/logging/__init__.py`重导出，避免导入混乱

## 审批状态

- [ ] 全后端架构设计已审阅（✅ 修正ProcessorFormatter桥接方案）
- [ ] 技术方案已确认（✅ 解决ComponentType重复定义问题）  
- [ ] 迁移策略已批准（✅ 修正API集成代码错误）
- [ ] 准备开始实施（✅ 所有review意见已修正）

## 版本历史

**v1.1** (当前版本)
- ✅ 修正stdlib桥接使用ProcessorFormatter方案
- ✅ 解决ComponentType重复定义，采用单一来源维护
- ✅ 修正API集成代码片段错误（导入、字段、上下文清理）
- ✅ 移除时间戳重复问题
- ✅ 添加force_reconfigure和access_logs配置选项

**v1.0** (原始版本)
- 基础全后端日志架构设计

---
*此文档由 spec-task:impl-task-plan 生成，经专业review修正为生产就绪的全后端通用日志架构，作为任务10（结构化日志）的详细实施指导*
