---
description: Execute spec tasks using TDD methodology
allowed-tools: Bash, Read, Write, Edit, MultiEdit, Grep, Glob, LS, WebFetch
argument-hint: <feature-name> <task-numbers>
---

# 使用TDD执行规范任务

使用Kent Beck的测试驱动开发方法从规范执行实施任务。

## 参数：$ARGUMENTS

## 说明

### 帮助模式（--help）

如果参数包含"--help"，显示用法：

```
/spec-task:impl <功能名称> <任务编号>

示例：
  /spec-task:impl auth-system 1.1            # 执行任务 1.1
  /spec-task:impl auth-system 1,2,3          # 执行任务 1、2、3
  /spec-task:impl auth-system --all          # 执行所有待处理任务
```

### 执行前验证

功能名称：!`echo "$ARGUMENTS" | awk '{print $1}' | head -1`

验证所需文件是否存在：

- 需求：检查 `.tasks/<功能名称>/requirements.md` 是否存在
- 高层设计：检查 `.tasks/<功能名称>/design-hld.md` 是否存在
- 低层设计：检查 `.tasks/<功能名称>/design-lld.md` 是否存在
- 任务：检查 `.tasks/<功能名称>/tasks.md` 是否存在
- 元数据：检查 `.tasks/<功能名称>/spec.json` 是否存在

### 上下文加载

**执行前加载所有必需的内容：**

核心指导和自定义指导文件将提供整体项目上下文。

**规范文档：**
功能名称目录：!`echo "$ARGUMENTS" | awk '{print $1}' | head -1`

- 需求：`.tasks/<功能名称>/requirements.md`
- 高层设计：`.tasks/<功能名称>/design-hld.md`
- 低层设计：`.tasks/<功能名称>/design-lld.md`
- 任务：`.tasks/<功能名称>/tasks.md`

**注意**：<功能名称> 将在执行期间替换为实际的功能名称

【可选：前置规划支持】

**整体技术规划**：
- 若存在 `.tasks/<功能名称>/impl-plan.md` 且在 `spec.json` 中 `impl_plan.approved=true`：
  - 作为权威参考优先加载该文档与 `.tasks/<功能名称>/references/` 缓存（接口签名、示例、坑点）
  - 实现阶段应以此为依据，减少重复检索；若发现偏差，需回写更新 `impl-plan.md`
- 若不存在或未批准：按需即时查询库文档（见下文"库文档查询"），但建议先执行 `/spec-task:impl-plan <功能名称>`

**任务级详细规划**：
- 若存在 `.tasks/<功能名称>/task-plans/<任务编号>.md` 且在 `spec.json` 中 `task_plans.<任务编号>.approved=true`：
  - 作为该任务的实施蓝图，严格按照计划的步骤执行
  - 使用计划中定义的测试用例和验收标准
  - 遵循计划中的TDD步骤顺序
- 若不存在或未批准：按照标准TDD流程执行，对复杂任务建议先执行 `/spec-task:task-plan <功能名称> <任务编号>`

### 任务执行

1. **从参数解析功能名称和任务编号**
2. **加载所有上下文**（指导 + 规范文档）
3. **从tasks.md提取复选框**
4. **直接使用TDD方法执行每个复选框**

### 对于每个任务复选框

直接使用TDD方法执行：

**实施步骤：**

1. **加载项目上下文**（首先读取这些文件）：
   - 规范元数据：`.tasks/<功能名称>/spec.json`
   - 需求：`.tasks/<功能名称>/requirements.md`
   - 高层设计：`.tasks/<功能名称>/design-hld.md`
   - 低层设计：`.tasks/<功能名称>/design-lld.md`
   - 所有任务：`.tasks/<功能名称>/tasks.md`
   - 任务计划（如果存在）：`.tasks/<功能名称>/task-plans/<任务编号>.md`

2. **针对每个特定任务的TDD实施**：
   - **库文档查询（必需）**：在开始实施前，使用 context7 获取任务中涉及库的最新接口、方法签名和调用示例
   - **红灯（RED）**：首先编写失败的测试
   - **绿灯（GREEN）**：编写最少的代码使测试通过，使用从 context7 获取的准确接口
   - **重构（REFACTOR）**：清理和改进代码结构，遵循库的最佳实践

3. **任务完成**：
   - 验证所有测试通过
   - **强制质量检验**：使用专门的代理进行最终验证
     - 使用 **code-simplifier** 代理检查代码复杂度并简化重构
     - 使用 **code-review-expert** 代理进行代码质量审查
   - 在 .tasks/<功能名称>/tasks.md 中将复选框从 `- [ ]` 更新为 `- [x]`
   - 确保现有测试没有回归

**对于每个任务：**

- 从 tasks.md 提取确切的复选框内容
- 严格遵循 Kent Beck 的 TDD 方法
- 仅实施特定的任务需求
- 保持代码质量和测试覆盖率

## 实施逻辑

1. **解析参数**：
   - 功能名称：第一个参数
   - 任务编号：第二个参数（支持："1"、"1,2,3"、"--all"）

2. **验证**：
   - 规范目录存在
   - 必需文件（requirements.md、design-hld.md、design-lld.md、tasks.md、spec.json）存在
   - 规范已批准可以实施

3. **执行**：
   - **首先将所有文件内容加载到内存中**
   - **构建完整的实施上下文**
   - **库文档准备**：对于每个任务，使用 context7 获取所需库的详细文档和接口信息
   - **使用TDD方法按顺序执行每个任务**
   - 每个任务实施都接收完整的项目知识和准确的库接口信息

## 错误处理

- 未找到规范：先运行 /spec-task:init
- 未批准：先完成规范工作流
- 任务失败：保持复选框未选中，显示错误

## 成功指标

- tasks.md 中所有选定的复选框都标记为 [x]
- 所有测试通过
- 代码通过质量审查（通过 code-review-expert 代理验证）
- 代码复杂度符合标准（通过 code-simplifier 代理验证和优化）
- 没有回归

---

## TDD方法详解

### 测试驱动开发核心原则

**TDD三步循环：**

1. **红灯阶段（Red）**
   - 编写一个失败的测试
   - 测试应该描述期望的行为
   - 运行测试确认它失败（因为功能还未实现）

2. **绿灯阶段（Green）**
   - 编写最少的代码使测试通过
   - 不要过度设计或优化
   - 目标是快速使测试变绿

3. **重构阶段（Refactor）**
   - 在测试保护下改进代码
   - 消除重复，提高可读性
   - 确保所有测试仍然通过

### TDD最佳实践

**库文档查询原则（强制要求）：**

- 在编写测试前，必须使用 context7 获取相关库的接口文档
- 确保使用的方法签名和参数与最新文档一致
- 获取库的最佳实践和常见使用模式
- 了解库的错误处理和异常情况

**测试编写原则：**

- 一次只编写一个测试
- 测试应该简单、独立、可重复
- 使用描述性的测试名称
- 遵循 Arrange-Act-Assert 模式
- 基于 context7 获取的接口信息编写准确的测试

**代码实施原则：**

- 从最简单的测试案例开始
- 逐步增加复杂性
- 保持测试和生产代码的平衡
- 频繁运行测试套件

**重构指导：**

- 仅在所有测试通过后重构
- 小步重构，频繁验证
- 关注代码的可读性和可维护性
- 应用SOLID原则和设计模式

### 任务执行流程示例

```
任务：实现用户认证系统

0. 库文档查询：使用 context7 获取库信息
   - 查询 FastAPI 的认证相关接口
   - 获取 SQLAlchemy 的用户模型最佳实践
   - 了解 bcrypt 的密码哈希方法签名
   - 查看 Pydantic 的验证模式

1. 红灯：编写测试
   - test_user_can_register()
   - 基于 context7 文档使用正确的接口
   - 预期：用户可以成功注册
   - 结果：测试失败（功能未实现）

2. 绿灯：实现功能
   - 创建User模型（使用 SQLAlchemy 最佳实践）
   - 实现register()方法（使用 bcrypt 正确接口）
   - 结果：测试通过

3. 重构：改进代码
   - 提取验证逻辑（遵循 Pydantic 模式）
   - 添加错误处理（使用 FastAPI 标准方式）
   - 优化数据库查询
   - 结果：测试仍然通过，代码更清晰

4. 最终质量验证（强制要求）：
   - 使用 code-simplifier 代理：检查并简化代码复杂度
   - 使用 code-review-expert 代理：审查代码质量和规范
   - 结果：所有代理验证通过，任务标记为完成
```

### 测试覆盖率要求

- 单元测试：核心业务逻辑 > 80%
- 集成测试：关键流程 100%
- 端到端测试：主要用户场景覆盖

### 持续集成注意事项

- 每次提交前运行所有测试
- 保持测试套件快速执行
- 修复失败的测试是最高优先级
- 维护测试环境的一致性

---

## 最终质量验证流程（强制要求）

每个任务完成后，必须按顺序使用以下两个专门代理进行质量验证：

### 1. 代码简化验证 (code-simplifier)

**用途**：检查代码复杂度并进行简化重构

**执行时机**：TDD 重构阶段完成后

**验证内容**：

- 检查函数和类的复杂度是否过高
- 识别重复代码和可提取的公共逻辑
- 简化过度复杂的条件逻辑
- 优化代码结构和可读性
- 确保遵循项目的代码约定

**通过标准**：

- 函数复杂度在合理范围内
- 无明显的代码重复
- 代码结构清晰易懂
- 遵循 SOLID 原则

### 2. 代码质量审查 (code-review-expert)

**用途**：进行综合代码质量审查

**执行时机**：代码简化完成后

**审查内容**：

- 代码风格和规范一致性
- 错误处理和边界条件
- 安全性考虑
- 性能潜在问题
- 可维护性和可扩展性
- API 设计合理性
- 文档和注释质量

**通过标准**：

- 代码符合项目规范
- 错误处理完善
- 无明显安全隐患
- 性能表现良好
- 具备良好的可维护性


### 代理验证执行流程

```
任务实施完成 →
1. 使用 code-simplifier 代理简化优化代码 →
2. 使用 code-review-expert 代理审查代码质量 →
3. 所有验证通过后，标记任务为完成 [x]
```

### 验证失败处理

如果任何一个代理验证失败：

- **不要标记任务为完成**
- 根据代理反馈修复问题
- 重新运行失败的代理验证
- 确保所有两个代理都通过后才能完成任务

### 质量门控标准

只有当所有两个代理验证都通过时，任务才能被标记为完成：

- ✅ code-simplifier: 代码简洁性通过
- ✅ code-review-expert: 代码质量通过
