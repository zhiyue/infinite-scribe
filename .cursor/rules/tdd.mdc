---
description: 
globs: 
alwaysApply: true
---
# TDD (测试驱动开发) 工作流

本项目遵循严格的测试驱动开发（TDD）方法论。所有新功能和错误修复都必须从一个失败的测试开始。

- **核心循环：红-绿-重构**
    1.  **红 (RED)**: 编写一个描述新功能点的测试。这个测试最初 **必须失败**，因为相应的功能尚未实现。
    2.  **绿 (GREEN)**: 编写最简单的代码让测试通过。在此阶段，无需担心代码质量或优化，唯一的目标就是让测试通过。
    3.  **重构 (REFACTOR)**: 清理刚刚编写的代码。在不改变其外部行为的前提下，改进代码结构、消除重复、提高可读性。重构后，所有测试必须仍然通过。

## 如何应用TDD

### 1. 编写第一个测试 (红)

在编写任何实现代码之前，先创建一个测试文件 (例如 `feature.test.ts`)。为所需功能定义一个测试用例。

```typescript
// ❌ 错误示范: 先写实现代码。

// ✅ 正确做法: 编写一个会失败的测试。
// 文件: src/utils/sum.test.ts
import { sum } from './sum';

describe('sum', () => {
  it('应该能正确地将两个数字相加', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

// 此时，`sum` 函数还不存在，所以这个测试会失败。
```

### 2. 让测试通过 (绿)

编写最少量的代码来让失败的测试通过。

```typescript
// 文件: src/utils/sum.ts
export const sum = (a: number, b: number): number => {
  return a + b;
};

// 现在，`sum.test.ts` 中的测试应该会通过。
```

### 3. 重构代码

回顾实现代码和测试代码，寻找改进的机会。

- 代码是否清晰易懂？
- 是否有应该成为常量的"魔法数字"或硬编码字符串？
- 是否有重复的逻辑？
- 能否在不牺牲可读性的情况下提高性能？

在 `sum` 的例子中，代码已经非常简单。对于更复杂的功能，这个步骤对于维护健康的代码库至关重要。

```typescript
// 重构示例（尽管对于 `sum` 函数来说并非必需）
// 假设我们因为某些原因想添加日志。
// 重构阶段是清晰地完成这类工作的地方。

// 文件: src/utils/sum.ts
export const sum = (a: number, b: number): number => {
  // console.log(`正在计算 ${a} 和 ${b} 的和`); // 可能是在"绿"阶段添加的
  return a + b; // 核心逻辑保持不变。
};

// 重构后，重新运行所有测试以确保没有破坏任何东西。
```

## 通用规则

- 除非有失败的测试要求，否则 **不允许添加新的生产代码**。
- **频繁提交**，最好在每个成功的"绿"或"重构"步骤之后提交。
- 保持测试 **小而专注**，每个测试只关注一个功能点。
- **经常运行完整的测试套件**，以确保没有引入回归。
